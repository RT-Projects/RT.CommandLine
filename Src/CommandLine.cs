using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using RT.Util.Consoles;
using RT.Util.ExtensionMethods;
using RT.Util.Lingo;
using RT.Util.Text;

namespace RT.Util.CommandLine
{
    /// <summary>
    ///     Implements a command-line parser that can turn the commands and options specified by the user on the command line
    ///     into a strongly-typed instance of a specific class. See remarks for more details.</summary>
    /// <remarks>
    ///     <para>
    ///         The following conditions must be met by the class wishing to receive the options and parameters:</para>
    ///     <list type="bullet">
    ///         <item><description>
    ///             It must be a reference type (a class) and it must have a parameterless constructor.</description></item>
    ///         <item><description>
    ///             <para>
    ///                 Every field in the class must have one of the following custom attributes:</para>
    ///             <list type="bullet">
    ///                 <item><description>
    ///                     <see cref="IsPositionalAttribute"/> (allowed for all supported types except <c>bool</c>) —
    ///                     specifies that the field is a positional parameter; the user specifies this as a single parameter
    ///                     without any extra syntax.</description></item>
    ///                 <item><description>
    ///                     <see cref="OptionAttribute"/> (allowed for all supported types except abstract classes) —
    ///                     specifies that the field is a parameter invoked by an option, e.g. <c>-x</c>. (This does not imply
    ///                     that the parameter is necessarily optional.)</description></item>
    ///                 <item><description>
    ///                     <see cref="EnumOptionsAttribute"/> (allowed for enum types only) — specifies that the field is a
    ///                     parameter that can be invoked by one of several options, which are specified on the enum values in
    ///                     the enum type.</description></item>
    ///                 <item><description>
    ///                     <see cref="IgnoreAttribute"/> — specifies that <see cref="CommandLineParser"/> shall completely
    ///                     ignore the field.</description></item></list></description></item>
    ///         <item><description>
    ///             <para>
    ///                 Each field may optionally have any of the following custom attributes:</para>
    ///             <list type="bullet">
    ///                 <item><description>
    ///                     <see cref="IsMandatoryAttribute"/> (allowed for all supported types except <c>bool</c>) —
    ///                     specifies that the parameter must be specified by the user. For a <c>string[]</c> field, it means
    ///                     that at least one value must be specified.</description></item>
    ///                 <item><description>
    ///                     <see cref="UndocumentedAttribute"/> — specifies that the option or command does not appear in the
    ///                     help screen generated by CommandLineParser.</description></item></list></description></item>
    ///         <item><description>
    ///             <para>
    ///                 Each field in the class must be of one of the following types:</para>
    ///             <list type="bullet">
    ///                 <item><description>
    ///                     <c>string</c>, any integer type, <c>float</c>, <c>double</c>, or any nullable version of these.
    ///                     The field can be positional (<see cref="IsPositionalAttribute"/>) or not (<see
    ///                     cref="OptionAttribute"/>).</description></item>
    ///                 <item><description>
    ///                     <c>string[]</c>. The field can be positional (<see cref="IsPositionalAttribute"/>) or not (<see
    ///                     cref="OptionAttribute"/>), but if it is positional, it must be the last field in the class.</description></item>
    ///                 <item><description>
    ///                     <c>bool</c>. The field must have an <see cref="OptionAttribute"/> and cannot be positional or
    ///                     mandatory.</description></item>
    ///                 <item><description>
    ///                     An abstract class with the <see cref="CommandGroupAttribute"/>. The field must be the last field
    ///                     in the class and must be marked positional (<see cref="IsPositionalAttribute"/>). The abstract
    ///                     class must have at least two derived classes, each with a <see cref="CommandNameAttribute"/>.</description></item>
    ///                 <item><description>
    ///                     <para>
    ///                         Any enum type. There are three ways that enum types can be used. To explain these, the
    ///                         following enum type declaraction is used as an example:</para>
    ///                     <code>
    ///                         enum OutputFormat { PlainText, Xml }</code>
    ///                     <list type="bullet">
    ///                         <item><description>
    ///                             <para>
    ///                                 <see cref="IsPositionalAttribute"/> — The user can specify a single parameter (e.g.
    ///                                 <c>plain</c> or <c>xml</c>) to select an enum value. Every value in the enum type must
    ///                                 have a <see cref="CommandNameAttribute"/> to specify the name by which that enum value
    ///                                 is selected:</para>
    ///                             <code>
    ///                                 enum OutputFormat
    ///                                 {
    ///                                     [CommandName("plain")]
    ///                                     PlainText,
    ///                                     [CommandName("xml")]
    ///                                     Xml
    ///                                 }</code></description></item>
    ///                         <item><description>
    ///                             <see cref="OptionAttribute"/> — The user can select an enum value by specifying an option
    ///                             followed by a parameter that identifies the enum value (e.g. <c>-x plain</c> or <c>-x
    ///                             xml</c>). As above, every value in the enum type must have a <see
    ///                             cref="CommandNameAttribute"/> to specify the name by which that enum value is selected.</description></item>
    ///                         <item><description>
    ///                             <para>
    ///                                 <see cref="EnumOptionsAttribute"/> — The user can select an enum value by specifying
    ///                                 just an option (e.g. <c>-p</c> or <c>-x</c>). Every value in the enum type must have
    ///                                 an <see cref="OptionAttribute"/> to specify the option by which that enum value is
    ///                                 selected:</para>
    ///                             <code>
    ///                                 enum OutputFormat
    ///                                 {
    ///                                     [Option("-p", "--plain")]
    ///                                     PlainText,
    ///                                     [Option("-x", "--xml")]
    ///                                     Xml
    ///                                 }</code>
    ///                             <para>
    ///                                 A parameter on the attribute determines whether the user is allowed to specify only
    ///                                 one enum value or multiple (which will be combined using bitwise or).</para></description></item>
    ///                         <item><description>
    ///                             If the field is optional, the enum value that corresponds to the field’s initial (default)
    ///                             value may omit the <see cref="CommandNameAttribute"/> or <see cref="OptionAttribute"/>.</description></item></list></description></item></list></description></item>
    ///         <item><description>
    ///             <para>
    ///                 Every field must have documentation or be explicitly marked with <see cref="UndocumentedAttribute"/>,
    ///                 except for fields that use <see cref="EnumOptionsAttribute"/> or <see cref="IgnoreAttribute"/>. For
    ///                 every field whose type is an enum type, the values in the enum type must also have documentation or
    ///                 <see cref="UndocumentedAttribute"/>, except for the enum value that corresponds to the field’s default
    ///                 value if the field is not mandatory.</para>
    ///             <para>
    ///                 Documentation is provided in one of the following ways:</para>
    ///             <list type="bullet">
    ///                 <item><description>
    ///                     Monolingual, translation-agnostic (unlocalisable) applications use the <see
    ///                     cref="DocumentationAttribute"/> to specify documentation directly.</description></item>
    ///                 <item><description>
    ///                     <para>
    ///                         Translatable applications must declare methods with the following signature:</para>
    ///                     <code>
    ///                         static string FieldNameDoc(Translation)</code>
    ///                     <para>
    ///                         The first parameter must be of the same type as the object passed in for the
    ///                         <c>applicationTr</c> parameter of <see cref="Parse"/>. The name of the method is the name of
    ///                         the field or enum value followed by <c>Doc</c>. The return value is the translated string.</para></description></item></list></description></item>
    ///         <item><description>
    ///             <see cref="IsPositionalAttribute"/> and <see cref="IsMandatoryAttribute"/> can be used together. However,
    ///             a positional field can only be made mandatory if all the positional fields preceding it are also
    ///             mandatory.</description></item></list></remarks>
    public static class CommandLineParser
    {
        /// <summary>
        ///     Parses the specified command-line arguments into an instance of the specified type. See the remarks section of
        ///     the documentation for <see cref="CommandLineParser"/> for features and limitations.</summary>
        /// <typeparam name="TArgs">
        ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
        /// <param name="args">
        ///     The command-line arguments to be parsed.</param>
        /// <param name="applicationTr">
        ///     Specifies the application’s translation object which contains the localised strings that document the
        ///     command-line options and commands. This object is passed in to the <c>FieldNameDoc</c> methods described in
        ///     the documentation for <see cref="CommandLineParser"/>. This should be <c>null</c> for monoligual applications.</param>
        /// <param name="helpProcessor">
        ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
        ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
        /// <returns>
        ///     An instance of the class <typeparamref name="TArgs"/> containing the options and parameters specified by the
        ///     user on the command line.</returns>
        public static TArgs Parse<TArgs>(string[] args, TranslationBase applicationTr = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
        {
            return (TArgs) parseCommandLine(args, typeof(TArgs), 0, applicationTr, helpProcessor);
        }

        /// <summary>
        ///     Parses the specified command-line arguments into an instance of the specified type. In case of failure, prints
        ///     usage information to the console and returns <c>default(TArgs)</c>. See the remarks section of the
        ///     documentation for <see cref="CommandLineParser"/> for features and limitations.</summary>
        /// <typeparam name="TArgs">
        ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
        /// <param name="args">
        ///     The command-line arguments to be parsed.</param>
        /// <param name="applicationTr">
        ///     Specifies the application’s translation object which contains the localised strings that document the
        ///     command-line options and commands. This object is passed in to the FieldNameDoc() methods described in the
        ///     documentation for <see cref="CommandLineParser"/>. This should be null for monoligual applications.</param>
        /// <param name="helpProcessor">
        ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
        ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
        /// <returns>
        ///     An instance of the class <typeparamref name="TArgs"/> containing the options and parameters specified by the
        ///     user on the command line.</returns>
        public static TArgs ParseOrWriteUsageToConsole<TArgs>(string[] args, TranslationBase applicationTr = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
        {
            try
            {
                return (TArgs) parseCommandLine(args, typeof(TArgs), 0, applicationTr, helpProcessor);
            }
            catch (CommandLineParseException e)
            {
                e.WriteUsageInfoToConsole();
                return default(TArgs);
            }
        }

        private sealed class positionalParameterInfo
        {
            public Action ProcessParameter;
            public Action ProcessEndOfParameters;
        }

        /// <summary>
        ///     Generates the help screen for this command line.</summary>
        /// <typeparam name="TArgs">
        ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
        /// <param name="applicationTr">
        ///     Specifies the application’s translation object which contains the localised strings that document the
        ///     command-line options and commands. This object is passed in to the <c>FieldNameDoc</c> methods described in
        ///     the documentation for <see cref="CommandLineParser"/>. This should be <c>null</c> for monoligual applications.</param>
        /// <param name="commandLineTr">
        ///     The instance containing the translation of <see cref="CommandLineParser"/>’s own text, or <c>null</c> for
        ///     English.</param>
        /// <param name="wrapWidth">
        ///     The character width at which the output should be word-wrapped. The default (<c>null</c>) uses <see
        ///     cref="ConsoleUtil.WrapToWidth"/>.</param>
        /// <param name="subType">
        ///     Optionally, a class that is used as a subcommand within the command-line syntax. Generates help for the
        ///     subcommand.</param>
        /// <param name="helpProcessor">
        ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
        ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
        public static ConsoleColoredString GenerateHelp<TArgs>(TranslationBase applicationTr = null, Translation commandLineTr = null, int? wrapWidth = null, Type subType = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
        {
            return getHelpGenerator(subType ?? typeof(TArgs), applicationTr, helpProcessor)(commandLineTr, wrapWidth ?? ConsoleUtil.WrapToWidth());
        }

        private static object parseCommandLine(string[] args, Type type, int i, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
        {
            if (i < args.Length)
                if (args[i] == "-?" || args[i] == "/?" || args[i] == "--?" || args[i] == "/h" || args[i] == "--help" || args[i] == "-help" || args[i] == "help")
                    throw new CommandLineHelpRequestedException(getHelpGenerator(type, applicationTr, helpProcessor));

            var ret = Activator.CreateInstance(type, true);
            var options = new Dictionary<string, Action>();
            var positionals = new List<positionalParameterInfo>();
            var missingMandatories = new List<FieldInfo>();
            FieldInfo swallowingField = null;
            var haveSeenOptionalPositional = false;

            foreach (var fieldForeach in type.GetFields())
            {
                var field = fieldForeach; // This is necessary for the lambda expressions to work

                if (field.IsDefined<IgnoreAttribute>())
                    continue;

                var positional = field.IsDefined<IsPositionalAttribute>();
                var option = field.GetCustomAttributes<OptionAttribute>().FirstOrDefault();
                var mandatory = field.IsDefined<IsMandatoryAttribute>();

                if (positional && mandatory && haveSeenOptionalPositional)
                    throw new InternalErrorException("Cannot have positional mandatory parameter after a positional optional one.");

                if (positional && !mandatory)
                    haveSeenOptionalPositional = true;

                if (mandatory)
                    missingMandatories.Add(field);

                // ### ENUM fields
                if (field.FieldType.IsEnum)
                {
                    // ### ENUM fields, positional
                    if (positional)
                    {
                        positionals.Add(new positionalParameterInfo
                        {
                            ProcessParameter = () =>
                            {
                                positionals.RemoveAt(0);
                                missingMandatories.Remove(field);
                                foreach (var enumField in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
                                {
                                    if (enumField.GetCustomAttributes<CommandNameAttribute>().First().Names.Any(c => c.Equals(args[i], StringComparison.OrdinalIgnoreCase)))
                                    {
                                        field.SetValue(ret, enumField.GetValue(null));
                                        i++;
                                        return;
                                    }
                                }
                                throw new UnrecognizedCommandOrOptionException(args[i], getHelpGenerator(type, applicationTr, helpProcessor));
                            },
                            ProcessEndOfParameters = () =>
                            {
                                if (mandatory)
                                    throw new MissingParameterException(field, null, false, getHelpGenerator(type, applicationTr, helpProcessor));
                            }
                        });
                    }
                    // ### ENUM fields
                    else
                    {
                        // Take care of both option+name scheme (e.g. “-x foo -x bar”) and option scheme (e.g. “-x -y”)
                        var behavior = field.GetCustomAttributes<EnumOptionsAttribute>().Select(eoa => eoa.Behavior).FirstOrDefault(EnumBehavior.SingleValue);
                        var underlyingType = field.FieldType.GetEnumUnderlyingType();

                        var infos = option == null
                            ? field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).Select(enumField => new
                            {
                                Options = enumField.GetOrderedOptionAttributeNames(),
                                NeedCommandName = false,
                                GetEnumValue = Ut.Lambda((string commandName) => enumField.GetRawConstantValue())
                            })
                            : Ut.NewArray(new
                            {
                                Options = option.Names,
                                NeedCommandName = true,
                                GetEnumValue = Ut.Lambda((string commandName) =>
                                {
                                    var enumField = field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public)
                                        .FirstOrDefault(ef => ef.GetCustomAttributes<CommandNameAttribute>().Any(cna => cna.Names.Contains(commandName)));
                                    if (enumField == null)
                                        throw new UnrecognizedCommandOrOptionException(commandName, getHelpGenerator(type, applicationTr, helpProcessor));
                                    return enumField.GetRawConstantValue();
                                })
                            }).AsEnumerable();

                        object prev = null;
                        string prevOptionOrCommand = null;

                        foreach (var infForeach in infos)
                        {
                            var inf = infForeach;
                            if (inf.Options == null)
                                // Assume that this is the default option
                                continue;
                            foreach (var oForeach in inf.Options)
                            {
                                var o = oForeach;
                                options[o] = () =>
                                {
                                    i++;
                                    string commandName = null;
                                    if (inf.NeedCommandName)
                                    {
                                        if (i >= args.Length)
                                            throw new IncompleteOptionException(o, getHelpGenerator(type, applicationTr, helpProcessor));
                                        commandName = args[i];
                                        i++;
                                    }
                                    missingMandatories.Remove(field);
                                    var value = inf.GetEnumValue(commandName);

                                    if (behavior == EnumBehavior.SingleValue)
                                    {
                                        if (prev == null)
                                        {
                                            prev = value;
                                            prevOptionOrCommand = commandName ?? o;
                                            field.SetValue(ret, value);
                                        }
                                        else if (prev.Equals(value))
                                        {
                                            // Don’t throw an error if the same value is simply specified multiple times. Just ignore the second occurrence
                                        }
                                        else
                                        {
                                            // Since only a single value is allowed, throw an error if another value is specified later
                                            throw new IncompatibleCommandOrOptionException(prevOptionOrCommand, commandName ?? o, getHelpGenerator(type, applicationTr, helpProcessor));
                                        }
                                    }
                                    else
                                    {
                                        if (underlyingType == typeof(ulong))
                                            prev = (prev == null ? 0UL : (ulong) prev) | (ulong) value;
                                        else
                                            prev = (prev == null ? 0L : Convert.ToInt64(prev)) | Convert.ToInt64(value);
                                        field.SetValue(ret, Convert.ChangeType(prev, underlyingType));
                                    }
                                };
                            }
                        }
                    }
                }
                // ### BOOL fields
                else if (field.FieldType == typeof(bool))
                {
                    foreach (var o in field.GetOrderedOptionAttributeNames())
                        options[o] = () => { field.SetValue(ret, true); i++; missingMandatories.Remove(field); };
                }
                // ### STRING and INTEGER fields (including nullable)
                else if (field.FieldType == typeof(string) || ExactConvert.IsTrueIntegerType(field.FieldType) || ExactConvert.IsTrueIntegerNullableType(field.FieldType) ||
                    field.FieldType == typeof(float) || field.FieldType == typeof(float?) || field.FieldType == typeof(double) || field.FieldType == typeof(double?))
                {
                    if (positional)
                    {
                        positionals.Add(new positionalParameterInfo
                        {
                            ProcessParameter = () =>
                            {
                                if (!convertStringAndSetField(args[i], ret, field))
                                    throw new InvalidNumericParameterException(field.Name, getHelpGenerator(type, applicationTr, helpProcessor));

                                positionals.RemoveAt(0);
                                missingMandatories.Remove(field);
                                i++;
                            },
                            ProcessEndOfParameters = () =>
                            {
                                if (mandatory)
                                    throw new MissingParameterException(field, null, false, getHelpGenerator(type, applicationTr, helpProcessor));
                            }
                        });
                    }
                    else
                    {
                        foreach (var oForeach in field.GetOrderedOptionAttributeNames())
                        {
                            var o = oForeach;
                            options[o] = () =>
                            {
                                i++;
                                if (i >= args.Length)
                                    throw new IncompleteOptionException(o, getHelpGenerator(type, applicationTr, helpProcessor));

                                if (!convertStringAndSetField(args[i], ret, field))
                                    throw new InvalidNumericParameterException(field.Name, getHelpGenerator(type, applicationTr, helpProcessor));

                                i++;
                                missingMandatories.Remove(field);
                            };
                        }
                    }
                }
                // ### STRING[] fields
                else if (field.FieldType == typeof(string[]))
                {
                    if (positional)
                    {
                        positionals.Add(new positionalParameterInfo
                        {
                            ProcessParameter = () =>
                            {
                                missingMandatories.Remove(field);
                                var prev = (string[]) field.GetValue(ret);
                                if (prev == null || prev.Length == 0)
                                    field.SetValue(ret, new string[] { args[i] });
                                else
                                    field.SetValue(ret, prev.Concat(args[i]).ToArray());
                                i++;
                            },
                            ProcessEndOfParameters = () =>
                            {
                                if (field.GetValue(ret) == null)
                                    field.SetValue(ret, new string[] { });
                            }
                        });
                    }
                    else
                    {
                        string[] prev = null;
                        foreach (var oForeach in field.GetOrderedOptionAttributeNames())
                        {
                            var o = oForeach;
                            options[o] = () =>
                            {
                                i++;
                                if (i >= args.Length)
                                    throw new IncompleteOptionException(o, getHelpGenerator(type, applicationTr, helpProcessor));
                                prev = (prev == null || prev.Length == 0)
                                    ? new string[] { args[i] }
                                    : prev.Concat(args[i]).ToArray();
                                field.SetValue(ret, prev);
                                i++;
                                missingMandatories.Remove(field);
                            };
                        }
                    }
                }
                // ### Command-group classes
                else if (field.FieldType.IsClass && field.FieldType.IsDefined<CommandGroupAttribute>())
                {
                    swallowingField = field;
                    positionals.Add(new positionalParameterInfo
                    {
                        ProcessParameter = () =>
                        {
                            missingMandatories.Remove(field);
                            positionals.RemoveAt(0);
                            foreach (var subclass in field.FieldType.Assembly.GetTypes().Where(t => !t.IsAbstract && t.IsSubclassOf(field.FieldType)))
                                if (subclass.GetCustomAttributes<CommandNameAttribute>().First().Names.Any(c => c.Equals(args[i], StringComparison.OrdinalIgnoreCase)))
                                {
                                    field.SetValue(ret, parseCommandLine(args, subclass, i + 1, applicationTr, helpProcessor));
                                    i = args.Length;
                                    return;
                                }
                            throw new UnrecognizedCommandOrOptionException(args[i], getHelpGenerator(type, applicationTr, helpProcessor));
                        },
                        ProcessEndOfParameters = () =>
                        {
                            if (mandatory)
                                throw new MissingParameterException(field, null, false, getHelpGenerator(type, applicationTr, helpProcessor));
                        }
                    });
                }
                else
                    // This only happens if the post-build check didn't run
                    throw new InternalErrorException("{0}.{1} is not of a supported type.".Fmt(type.FullName, field.Name));
            }

            bool suppressOptions = false;

            while (i < args.Length)
            {
                if (args[i] == "--" && !suppressOptions)
                {
                    suppressOptions = true;
                    i++;
                }
                else if (!suppressOptions && args[i].StartsWith('-'))
                {
                    if (options.ContainsKey(args[i]))
                        options[args[i]]();
                    else
                        throw new UnrecognizedCommandOrOptionException(args[i], getHelpGenerator(type, applicationTr, helpProcessor));
                }
                else
                {
                    if (positionals.Count == 0)
                        throw new UnexpectedArgumentException(args.Subarray(i), getHelpGenerator(type, applicationTr, helpProcessor));
                    positionals[0].ProcessParameter();
                }
            }

            if (positionals.Count > 0)
                positionals[0].ProcessEndOfParameters();

            if (missingMandatories.Count > 0)
                throw new MissingParameterException(missingMandatories[0], swallowingField, !missingMandatories[0].IsDefined<IsPositionalAttribute>(), getHelpGenerator(type, applicationTr, helpProcessor));

            Type[] typeParam;
            ConsoleColoredString error = null;
            if (type.TryGetInterfaceGenericParameters(typeof(ICommandLineValidatable<>), out typeParam))
            {
                var tp = typeof(ICommandLineValidatable<>).MakeGenericType(typeParam[0]);
                if (typeParam[0] != applicationTr.GetType())
                    throw new CommandLineValidationException(@"The type {0} implements {1}, but ApplicationTr is of type {2}. If ApplicationTr is right, the interface implemented should be {3}.".Fmt(
                        type.FullName,
                        tp.FullName,
                        applicationTr.GetType().FullName,
                        typeof(ICommandLineValidatable<>).MakeGenericType(applicationTr.GetType()).FullName
                    ), getHelpGenerator(type, applicationTr, helpProcessor));

                var meth = tp.GetMethod("Validate");
                if (meth == null || !meth.GetParameters().Select(p => p.ParameterType).SequenceEqual(new Type[] { typeParam[0] }))
                    throw new CommandLineValidationException(@"Couldn’t find the Validate method in the {0} type.".Fmt(tp.FullName), getHelpGenerator(type, applicationTr, helpProcessor));

                error = (ConsoleColoredString) meth.Invoke(ret, new object[] { applicationTr });
            }
            else if (typeof(ICommandLineValidatable).IsAssignableFrom(type))
                error = ((ICommandLineValidatable) ret).Validate();

            if (error != null)
                throw new CommandLineValidationException(error, getHelpGenerator(type, applicationTr, helpProcessor));

            return ret;
        }

        private static bool convertStringAndSetField(string value, object cmdLineObject, FieldInfo field)
        {
            object result;

            if (field.FieldType == typeof(string))
                result = value;
            else
            {
                Type type = field.FieldType.IsGenericType && field.FieldType.GetGenericTypeDefinition() == typeof(Nullable<>)
                    ? field.FieldType.GetGenericArguments()[0]
                    : field.FieldType;
                if (!ExactConvert.Try(type, value, out result))
                    return false;
            }
            field.SetValue(cmdLineObject, result);
            return true;
        }

        private static Func<Translation, int, ConsoleColoredString> getHelpGenerator(Type type, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
        {
            helpProcessor = helpProcessor ?? (s => s);
            return (tr, wrapWidth) =>
            {
                if (tr == null)
                    tr = new Translation();

                int leftMargin = 3;

                var helpString = new List<ConsoleColoredString>();
                var commandNameAttr = type.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
                string commandName = commandNameAttr == null ? Path.GetFileNameWithoutExtension(Assembly.GetEntryAssembly().Location) : "... " + commandNameAttr.Names.OrderByDescending(c => c.Length).First();

                //
                //  ##  CONSTRUCT THE “USAGE” LINE
                //
                var usage = new List<ConsoleColoredString>();
                usage.Add(new ConsoleColoredString(tr.Usage + " ", CmdLineColor.UsageLinePrefix));
                usage.Add(commandName);

                List<FieldInfo> optionalOptions, mandatoryOptions, optionalPositional, mandatoryPositional;
                getFieldsForHelp(type, out optionalOptions, out mandatoryOptions, out optionalPositional, out mandatoryPositional);

                // Options must be listed before positionals because if a positional is a subcommand, all the options must be before it.
                // optionalPositional must come after mandatoryPositional because that is the order they must be specified in.
                // If any mandatoryPositional is a subcommand, then you can’t have any optionalPositionals anyway.
                usage.Add(
                    mandatoryOptions.Select(fld => new { Mandatory = true, Field = fld })
                        .Concat(optionalOptions.Select(fld => new { Mandatory = false, Field = fld }))
                        .Concat(mandatoryPositional.Select(fld => new { Mandatory = true, Field = fld }))
                        .Concat(optionalPositional.Select(fld => new { Mandatory = false, Field = fld }))
                        .Select(f => " " + f.Field.FormatParameterUsage(f.Mandatory))
                        .JoinColoredString());

                // Word-wrap the usage line
                foreach (var line in new ConsoleColoredString(usage.ToArray()).WordWrap(wrapWidth, tr.Usage.Translation.Length + 1))
                {
                    helpString.Add(line);
                    helpString.Add(ConsoleColoredString.NewLine);
                }
                helpString.Add(ConsoleColoredString.NewLine);

                //
                //  ##  CONSTRUCT THE TABLES
                //

                var anyCommandsWithSuboptions = false;
                var requiredParamsTable = new TextTable { MaxWidth = wrapWidth - leftMargin, ColumnSpacing = 3, RowSpacing = 1, LeftMargin = leftMargin };
                int requiredRow = 0;
                foreach (var f in mandatoryPositional.Select(fld => new { Positional = true, Field = fld }).Concat(mandatoryOptions.Select(fld => new { Positional = false, Field = fld })))
                    anyCommandsWithSuboptions |= createParameterHelpRow(ref requiredRow, requiredParamsTable, f.Field, f.Positional, type, applicationTr, helpProcessor);

                var optionalParamsTable = new TextTable { MaxWidth = wrapWidth - leftMargin, ColumnSpacing = 3, RowSpacing = 1, LeftMargin = leftMargin };
                int optionalRow = 0;
                foreach (var f in optionalPositional.Select(fld => new { Positional = true, Field = fld }).Concat(optionalOptions.Select(fld => new { Positional = false, Field = fld })))
                    anyCommandsWithSuboptions |= createParameterHelpRow(ref optionalRow, optionalParamsTable, f.Field, f.Positional, type, applicationTr, helpProcessor);

                // Word-wrap the documentation for the command (if any)
                var doc = getDocumentation(type, type, applicationTr, helpProcessor);
                foreach (var line in doc.WordWrap(wrapWidth))
                {
                    helpString.Add(line);
                    helpString.Add(ConsoleColoredString.NewLine);
                }

                // Table of required parameters
                if (mandatoryOptions.Any() || mandatoryPositional.Any())
                {
                    helpString.Add(ConsoleColoredString.NewLine);
                    helpString.Add(new ConsoleColoredString(tr.ParametersHeader, CmdLineColor.HelpHeading));
                    helpString.Add(ConsoleColoredString.NewLine);
                    helpString.Add(ConsoleColoredString.NewLine);
                    requiredParamsTable.RemoveEmptyColumns();
                    helpString.Add(requiredParamsTable.ToColoredString());
                }

                // Table of optional parameters
                if (optionalOptions.Any() || optionalPositional.Any())
                {
                    helpString.Add(ConsoleColoredString.NewLine);
                    helpString.Add(new ConsoleColoredString(tr.OptionsHeader, CmdLineColor.HelpHeading));
                    helpString.Add(ConsoleColoredString.NewLine);
                    helpString.Add(ConsoleColoredString.NewLine);
                    optionalParamsTable.RemoveEmptyColumns();
                    helpString.Add(optionalParamsTable.ToColoredString());
                }

                // “This command accepts further arguments on the command line.”
                if (anyCommandsWithSuboptions)
                {
                    helpString.Add(ConsoleColoredString.NewLine);
                    foreach (var line in (new ConsoleColoredString("* ", CmdLineColor.SubcommandsPresentAsterisk) + ConsoleColoredString.FromEggsNode(EggsML.Parse(tr.AdditionalOptions.Translation))).WordWrap(wrapWidth, 2))
                    {
                        helpString.Add(line);
                        helpString.Add(ConsoleColoredString.NewLine);
                    }
                }

                return new ConsoleColoredString(helpString.ToArray());
            };
        }

        private static bool createParameterHelpRow(ref int row, TextTable table, FieldInfo field, bool positional, Type type, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
        {
            var anyCommandsWithSuboptions = false;
            var cmdName = "<".Color(CmdLineColor.FieldBrackets) + field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets);

            if (field.FieldType.IsEnum)
            {
                // ### ENUM fields, positional
                if (positional)
                {
                    var topRow = row;
                    var doc = getDocumentation(field, type, applicationTr, helpProcessor);
                    if (doc.Length > 0 || field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).All(el => el.IsDefined<UndocumentedAttribute>() || !el.GetCustomAttributes<CommandNameAttribute>().Any()))
                    {
                        table.SetCell(2, row, doc, colSpan: 4);
                        row++;
                    }
                    foreach (var el in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
                    {
                        if (el.IsDefined<UndocumentedAttribute>())
                            continue;
                        var attr = el.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
                        if (attr == null)   // skip the default value
                            continue;
                        table.SetCell(2, row, attr.Names.Where(n => n.Length <= 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(", "), noWrap: true);
                        table.SetCell(3, row, attr.Names.Where(n => n.Length > 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(Environment.NewLine), noWrap: true);
                        table.SetCell(4, row, getDocumentation(el, type, applicationTr, helpProcessor), colSpan: 2);
                        row++;
                    }
                    table.SetCell(0, topRow, cmdName, noWrap: true, colSpan: 2, rowSpan: row - topRow);
                }
                // ### ENUM fields, “-x foo” scheme
                else if (field.IsDefined<OptionAttribute>())
                {
                    var topRow = row;
                    row++;
                    foreach (var el in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).Where(e => !e.IsDefined<UndocumentedAttribute>()))
                    {
                        var attr = el.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
                        if (attr == null)   // skip the default value
                            continue;
                        table.SetCell(3, row, attr.Names.Where(n => n.Length <= 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(", "), noWrap: true);
                        table.SetCell(4, row, attr.Names.Where(n => n.Length > 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(Environment.NewLine), noWrap: true);
                        table.SetCell(5, row, getDocumentation(el, type, applicationTr, helpProcessor));
                        row++;
                    }
                    if (row == topRow + 1)
                        throw new InvalidOperationException("Enum type {2}.{3} has no values (apart from default value for field {0}.{1}).".Fmt(field.DeclaringType.FullName, field.Name, field.FieldType.DeclaringType.FullName, field.FieldType));
                    table.SetCell(0, topRow, field.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true, rowSpan: row - topRow);
                    table.SetCell(1, topRow, field.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true, rowSpan: row - topRow);
                    table.SetCell(2, topRow, getDocumentation(field, type, applicationTr, helpProcessor), colSpan: 4);
                    table.SetCell(2, topRow + 1, cmdName, noWrap: true, rowSpan: row - topRow - 1);
                }
                // ### ENUM fields, “-x” scheme
                else
                {
                    foreach (var el in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).Where(e => e.IsDefined<OptionAttribute>() && !e.IsDefined<UndocumentedAttribute>()))
                    {
                        table.SetCell(0, row, el.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true);
                        table.SetCell(1, row, el.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true);
                        table.SetCell(2, row, getDocumentation(el, type, applicationTr, helpProcessor), colSpan: 4);
                        row++;
                    }
                }
            }
            // ### Command-group classes
            else if (field.FieldType.IsDefined<CommandGroupAttribute>())
            {
                int origRow = row;
                foreach (var ty in field.FieldType.Assembly.GetTypes()
                    .Where(t => t.IsSubclassOf(field.FieldType) && t.IsDefined<CommandNameAttribute>() && !t.IsAbstract && !t.IsDefined<UndocumentedAttribute>())
                    .OrderBy(t => t.GetCustomAttributes<CommandNameAttribute>().First().Names.MinElement(c => c.Length)))
                {
                    var cell1 = ConsoleColoredString.Empty;
                    var cell2 = ConsoleColoredString.Empty;
                    var suboptions = ty.GetAllFields().Any(fld => !fld.IsDefined<UndocumentedAttribute>());
                    anyCommandsWithSuboptions |= suboptions;
                    var asterisk = suboptions ? "*".Color(CmdLineColor.SubcommandsPresentAsterisk) : ConsoleColoredString.Empty;
                    var names = ty.GetCustomAttributes<CommandNameAttribute>().First().Names;
                    table.SetCell(2, row, names.Where(n => n.Length <= 2).Select(n => n.Color(CmdLineColor.Command) + asterisk).JoinColoredString(", "), noWrap: true);
                    table.SetCell(3, row, names.Where(n => n.Length > 2).Select(n => n.Color(CmdLineColor.Command) + asterisk).JoinColoredString(Environment.NewLine), noWrap: true);
                    table.SetCell(4, row, getDocumentation(ty, ty, applicationTr, helpProcessor), colSpan: 2);
                    row++;
                }
                table.SetCell(0, origRow, cmdName, colSpan: 2, rowSpan: row - origRow, noWrap: true);
            }
            // ### All other positional parameters
            else if (positional)
            {
                table.SetCell(0, row, cmdName, noWrap: true, colSpan: 2);
                table.SetCell(2, row, getDocumentation(field, type, applicationTr, helpProcessor), colSpan: 4);
                row++;
            }
            // ### All other non-positional parameters
            else
            {
                table.SetCell(0, row, field.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true);
                table.SetCell(1, row, field.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true);
                table.SetCell(2, row, getDocumentation(field, type, applicationTr, helpProcessor), colSpan: 4);
                row++;
            }
            return anyCommandsWithSuboptions;
        }

        private static void getFieldsForHelp(Type type, out List<FieldInfo> optionalOptions, out List<FieldInfo> mandatoryOptions, out List<FieldInfo> optionalPositional, out List<FieldInfo> mandatoryPositional)
        {
            optionalOptions = new List<FieldInfo>();
            mandatoryOptions = new List<FieldInfo>();
            optionalPositional = new List<FieldInfo>();
            mandatoryPositional = new List<FieldInfo>();

            foreach (var field in type.GetFields().Where(f => !f.IsDefined<UndocumentedAttribute>() && !f.IsDefined<IgnoreAttribute>()))
                (field.IsDefined<IsMandatoryAttribute>()
                    ? (field.IsDefined<IsPositionalAttribute>() ? mandatoryPositional : mandatoryOptions)
                    : (field.IsDefined<IsPositionalAttribute>() ? optionalPositional : optionalOptions)
                ).Add(field);
        }

        private static ConsoleColoredString getDocumentation(MemberInfo member, Type inType, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
        {
            if (member.IsDefined<DocumentationAttribute>())
                return helpProcessor(member.GetCustomAttributes<DocumentationAttribute>().Select(d => d.Text ?? "").First());
            if (applicationTr == null)
                return "";

            if (!(member is Type) && inType.IsSubclassOf(member.DeclaringType))
                inType = member.DeclaringType;
            var meth = inType.GetMethod(member.Name + "Doc", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { applicationTr.GetType() }, null);
            if (meth == null || meth.ReturnType != typeof(string))
                return "";
            var str = (string) meth.Invoke(null, new object[] { applicationTr });
            return str == null ? "" : helpProcessor(CommandLineParser.Colorize(EggsML.Parse(str)));
        }

        #region Post-build step check

        /// <summary>
        ///     Performs safety checks to ensure that the structure of your command-line syntax defining class is valid
        ///     according to the criteria laid out in the documentation of <see cref="CommandLineParser"/>. Run this method as
        ///     a post-build step to ensure reliability of execution. For an example of use, see <see
        ///     cref="Ut.RunPostBuildChecks"/>.</summary>
        /// <typeparam name="TArgs">
        ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
        /// <param name="rep">
        ///     Object to report post-build errors to.</param>
        /// <param name="applicationTrType">
        ///     The type of the translation object, derived from <see cref="TranslationBase"/>, which would be passed in for
        ///     the “applicationTr” parameter of <see cref="Parse"/> at normal run-time.</param>
        public static void PostBuildStep<TArgs>(IPostBuildReporter rep, Type applicationTrType)
        {
            postBuildStep(rep, typeof(TArgs), applicationTrType, false);
        }

        private static void postBuildStep(IPostBuildReporter rep, Type commandLineType, Type applicationTrType, bool classDocRecommended)
        {
            if (!commandLineType.IsClass)
                rep.Error(@"{0} is not a class.".Fmt(commandLineType.FullName), (commandLineType.IsEnum ? "enum " : commandLineType.IsInterface ? "interface " : typeof(Delegate).IsAssignableFrom(commandLineType) ? "delegate " : "struct ") + commandLineType.Name);

            object instance;
            try
            {
                instance = Activator.CreateInstance(commandLineType, true);
            }
            catch (Exception e)
            {
                rep.Error(@"{0} could not be instantiated ({1}). Does it have a default constructor?".Fmt(commandLineType.FullName, e.Message), "class " + commandLineType.Name);
                return;
            }

            if (applicationTrType != null)
            {
                Type[] typeParam;
                if (commandLineType.TryGetInterfaceGenericParameters(typeof(ICommandLineValidatable<>), out typeParam) && typeParam[0] != applicationTrType)
                    rep.Error(@"The type {0} implements {1}, but the ApplicationTr type is {2}. If ApplicationTr is right, the interface implemented should be {3}.".Fmt(
                        commandLineType.FullName,
                        typeof(ICommandLineValidatable<>).MakeGenericType(typeParam[0]).FullName,
                        applicationTrType.FullName,
                        typeof(ICommandLineValidatable<>).MakeGenericType(applicationTrType).FullName
                    ), "class " + commandLineType.Name);
            }

            var optionTaken = new Dictionary<string, MemberInfo>();
            var sensibleDocMethods = new List<MethodInfo>();
            FieldInfo lastField = null;
            bool haveSeenOptionalPositional = false;

            checkDocumentation(rep, commandLineType, commandLineType, applicationTrType, sensibleDocMethods, classDocRecommended);

            foreach (var field in commandLineType.GetFields())
            {
                if (field.IsDefined<IgnoreAttribute>())
                    continue;

                if (lastField != null)
                    rep.Error(@"The type of {0}.{1} necessitates that it is the last one in the class.".Fmt(lastField.DeclaringType.FullName, lastField.Name), "class " + commandLineType.Name, field.Name);

                // Every field must have one of the following
                var positional = field.IsDefined<IsPositionalAttribute>();
                var options = field.GetOrderedOptionAttributeNames();
                var enumOpt = field.GetCustomAttributes<EnumOptionsAttribute>().FirstOrDefault();

                if (!positional && options == null && enumOpt == null)
                {
                    rep.Error(@"{0}.{1}: Every field must have one of the following attributes: [IsPositional], [Option], [EnumOptions] (fields of an enum type only), or [Ignore].".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);
                    continue;
                }

                // EnumOptionsAttribute can only be used on enum fields
                if (enumOpt != null && !field.FieldType.IsEnum)
                    rep.Error(@"{0}.{1}: Cannot use [EnumOptions] attribute on a field whose type is not an enum type.".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);
                // Can’t combine IsPositional and Option
                else if (positional && options != null)
                    rep.Error(@"{0}.{1}: Cannot use [IsPositional] and [Option] attributes on the same field.".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);
                // Can’t combine IsPositional and EnumOptions
                else if (positional && enumOpt != null)
                    rep.Error(@"{0}.{1}: Cannot use [IsPositional] and [EnumOptions] attributes on the same field. For a positional enum value, use only [IsPositional].".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);
                // Can’t have [Option] without an option name
                else if (options != null && options.Length == 0)
                    rep.Error(@"{0}.{1}: An [Option] attribute must specify at least one option name.".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);

                // Option names must start with a dash
                if (options != null && options.Any(o => !o.StartsWith('-')))
                    rep.Error(@"{0}.{1}: All names in an [Option] attribute must start with at least one dash ('-'). Offending option name: ""{2}""".Fmt(field.DeclaringType.FullName, field.Name, options.First(o => !o.StartsWith('-'))), "class " + commandLineType.Name, field.Name);

                var mandatory = field.IsDefined<IsMandatoryAttribute>();

                if (mandatory && field.IsDefined<UndocumentedAttribute>())
                    rep.Error(@"{0}.{1}: Fields cannot simultaneously be mandatory and also undocumented.".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);

                if (positional && mandatory && haveSeenOptionalPositional)
                    rep.Error(@"{0}.{1}: Positional fields can only be marked mandatory if all preceding positional fields are also marked mandatory.".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);
                else if (positional && !mandatory)
                    haveSeenOptionalPositional = true;

                // ### ENUM fields
                if (field.FieldType.IsEnum)
                {
                    // Can’t have a mandatory or a positional multi-value enum
                    if (mandatory && enumOpt != null && enumOpt.Behavior == EnumBehavior.MultipleValues)
                        rep.Error(@"{0}.{1}: A mandatory enum field cannot use multi-value behavior.".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);
                    if (positional && enumOpt != null && enumOpt.Behavior == EnumBehavior.MultipleValues)
                        rep.Error(@"{0}.{1}: A positional enum field cannot use multi-value behavior.".Fmt(field.DeclaringType.FullName, field.Name), "class " + commandLineType.Name, field.Name);

                    var commandsTaken = new Dictionary<string, FieldInfo>();
                    var defaultValue = field.GetValue(instance);

                    foreach (var enumField in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
                    {
                        if (enumField.IsDefined<IgnoreAttribute>())
                            continue;
                        // If the field is not mandatory, it is allowed to have a default value
                        if (!mandatory && enumField.GetValue(null).Equals(defaultValue))
                            continue;

                        // check that the enum values all have documentation
                        checkDocumentation(rep, enumField, commandLineType, applicationTrType, sensibleDocMethods, true);

                        if (options != null || positional)
                        {
                            // check that the enum values all have at least one CommandName, and they do not clash
                            var cmdNames = enumField.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
                            if (cmdNames == null || cmdNames.Names.Length == 0)
                                rep.Error(@"{0}.{1} (used by {2}.{3}): Enum value must have a [CommandName] attribute (unless it is the field's default value and the field is optional).".Fmt(field.FieldType.FullName, enumField.Name, commandLineType.FullName, field.Name), "enum " + field.FieldType.Name, enumField.Name);
                            else
                                checkCommandNamesUnique(rep, cmdNames.Names, commandsTaken, commandLineType, field, enumField);
                        }
                        else
                        {
                            // check that the non-default enum values’ Options are present and do not clash
                            var optionNames = enumField.GetOrderedOptionAttributeNames();
                            if (optionNames == null || !optionNames.Any())
                                rep.Error(@"{0}.{1} (used by {2}.{3}): Enum value must have an [Option] attribute with at least one option name (unless it is the field's default value and the field is optional).".Fmt(field.FieldType.FullName, enumField.Name, commandLineType.FullName, field.Name), "enum " + field.FieldType.Name, enumField.Name);
                            else
                                checkOptionsUnique(rep, optionNames, optionTaken, commandLineType, field, enumField);
                        }
                    }

                    // If the enum field has an Option attribute, it needs documentation too
                    if (options != null)
                        checkDocumentation(rep, field, commandLineType, applicationTrType, sensibleDocMethods, true);
                }
                // ### BOOL fields
                else if (field.FieldType == typeof(bool))
                {
                    if (positional || mandatory)
                        rep.Error(@"{0}.{1}: Fields of type bool cannot be positional or mandatory.".Fmt(commandLineType.FullName, field.Name), "class " + commandLineType.Name, field.Name);
                    else
                        // Here we have checked that the field is not positional, not an enum, and not [Ignore]’d, so it must have an [Option] attribute
                        checkOptionsUnique(rep, options, optionTaken, commandLineType, field);
                    checkDocumentation(rep, field, commandLineType, applicationTrType, sensibleDocMethods, true);
                }
                // ### STRING, STRING[], INTEGER and FLOATING fields (including nullable)
                else if (field.FieldType == typeof(string) || field.FieldType == typeof(string[]) ||
                    (ExactConvert.IsTrueIntegerType(field.FieldType) && !field.FieldType.IsEnum) ||
                    (ExactConvert.IsTrueIntegerNullableType(field.FieldType) && !field.FieldType.GetGenericArguments()[0].IsEnum) ||
                    field.FieldType == typeof(float) || field.FieldType == typeof(float?) || field.FieldType == typeof(double) || field.FieldType == typeof(double?))
                {
                    // options is null if and only if this field is positional
                    if (options != null)
                        checkOptionsUnique(rep, options, optionTaken, commandLineType, field);
                    checkDocumentation(rep, field, commandLineType, applicationTrType, sensibleDocMethods, true);
                }
                // ### Command-group classes
                else if (field.FieldType.IsClass && field.FieldType.IsDefined<CommandGroupAttribute>())
                {
                    // Command-group class fields must be positional parameters
                    if (!positional)
                        rep.Error(@"{0}.{1}: CommandGroup fields must be declared [IsPositional].".Fmt(commandLineType.FullName, field.Name), "class " + commandLineType.Name, field.Name);

                    // The class must have at least two subclasses with a [CommandName] attribute
                    var subclasses = field.FieldType.Assembly.GetTypes().Where(t => !t.IsAbstract && t.IsSubclassOf(field.FieldType));
                    if (subclasses.Count() < 1)
                        rep.Error(@"{0}.{1}: The CommandGroup class type must have at least one non-abstract derived class with the [CommandName] attribute.".Fmt(commandLineType.FullName, field.Name), "class " + field.FieldType.Name);

                    var commandsTaken = new Dictionary<string, Type>();

                    foreach (var subclass in subclasses)
                    {
                        if (!subclass.IsDefined<CommandNameAttribute>())
                            rep.Error(@"{0}: This subclass of {1} must have a [CommandName] attribute or be marked abstract.".Fmt(subclass.FullName, field.FieldType.FullName), "class " + subclass.Name);
                        else
                            checkCommandNamesUnique(rep, subclass.GetCustomAttributes<CommandNameAttribute>().First().Names, commandsTaken, subclass);

                        // Recursively check this class
                        postBuildStep(rep, subclass, applicationTrType, true);
                    }

                    lastField = field;
                }
                else
                    rep.Error(@"{0}.{1} is not of a supported type. Currently accepted types are: enum types, bool, string, string[], numeric types (byte, sbyte, short, ushort, int, uint, long, ulong, float and double), nullable numeric types, and classes with the [CommandGroup] attribute.".Fmt(commandLineType.FullName, field.Name), "class " + commandLineType.Name, field.Name);
            }

            if (applicationTrType != null)
                // Warn if the class has unused documentation methods
                foreach (var meth in commandLineType.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).Where(m => m.Name.EndsWith("Doc") && m.ReturnType == typeof(string) && m.GetParameters().Select(p => p.ParameterType).SequenceEqual(new Type[] { applicationTrType })))
                    if (!sensibleDocMethods.Contains(meth))
                        rep.Error(@"{0}.{1} looks like a documentation method, but has no corresponding field, or the corresponding field does not require documentation because it is a positional enum or has an [EnumOptions] attribute.".Fmt(commandLineType.FullName, meth.Name), "class " + commandLineType.Name, meth.Name);
        }

        private static void checkOptionsUnique(IPostBuildReporter rep, IEnumerable<string> options, Dictionary<string, MemberInfo> optionTaken, Type type, FieldInfo field, FieldInfo enumField)
        {
            foreach (var option in options)
            {
                if (optionTaken.ContainsKey(option))
                {
                    rep.Error(@"{0}.{1}: Option ""{2}"" is used more than once.".Fmt(field.FieldType.FullName, enumField.Name, option), "enum " + field.FieldType.Name, enumField.Name);
                    rep.Error(@" -- It is used by {0}.{1}...".Fmt(type.FullName, field.Name), "class " + type.Name, field.Name);
                    rep.Error(@" -- ... and by {0}.{1}.".Fmt(optionTaken[option].DeclaringType.FullName, optionTaken[option].Name), "class " + optionTaken[option].DeclaringType.Name, optionTaken[option].Name);
                }
                optionTaken[option] = field;
            }
        }

        private static void checkOptionsUnique(IPostBuildReporter rep, IEnumerable<string> options, Dictionary<string, MemberInfo> optionTaken, Type type, FieldInfo field)
        {
            foreach (var option in options)
            {
                if (optionTaken.ContainsKey(option))
                {
                    rep.Error(@"Option ""{2}"" is used by {0}.{1}...".Fmt(type.FullName, field.Name, option), "class " + type.Name, field.Name);
                    rep.Error(@" -- ... and by {0}.{1}.".Fmt(optionTaken[option].DeclaringType.FullName, optionTaken[option].Name), "class " + optionTaken[option].DeclaringType.Name, optionTaken[option].Name);
                }
                optionTaken[option] = field;
            }
        }

        private static void checkCommandNamesUnique(IPostBuildReporter rep, string[] commandNames, Dictionary<string, Type> commandsTaken, Type subclass)
        {
            foreach (var cmd in commandNames)
            {
                if (commandsTaken.ContainsKey(cmd))
                {
                    rep.Error(@"CommandName ""{1}"" is used by {0}...".Fmt(subclass.FullName, cmd), "class " + subclass.Name);
                    rep.Error(@" -- ... and by {0}.".Fmt(commandsTaken[cmd].FullName), "class " + commandsTaken[cmd].Name);
                }
                commandsTaken[cmd] = subclass;
            }
        }

        private static void checkCommandNamesUnique(IPostBuildReporter rep, string[] commandNames, Dictionary<string, FieldInfo> commandsTaken, Type type, FieldInfo field, FieldInfo enumField)
        {
            foreach (var cmd in commandNames)
            {
                if (commandsTaken.ContainsKey(cmd))
                {
                    rep.Error(@"{0}.{1}: Option ""{2}"" is used more than once.".Fmt(field.FieldType.FullName, enumField.Name, cmd), "enum " + field.FieldType.Name, enumField.Name);
                    rep.Error(@" -- It is used by {0}.{1}...".Fmt(type.FullName, field.Name), "class " + type.Name, field.Name);
                    rep.Error(@" -- ... and by {0}.{1}.".Fmt(commandsTaken[cmd].DeclaringType.FullName, commandsTaken[cmd].Name), "class " + commandsTaken[cmd].DeclaringType.Name, commandsTaken[cmd].Name);
                }
                commandsTaken[cmd] = enumField;
            }
        }

        private static Dictionary<Type, object> _applicationTrCacheField = null;
        private static Dictionary<Type, object> _applicationTrCache
        {
            get
            {
                if (_applicationTrCacheField == null)
                    _applicationTrCacheField = new Dictionary<Type, object>();
                return _applicationTrCacheField;
            }
        }

        private static void checkDocumentation(IPostBuildReporter rep, MemberInfo member, Type inType, Type applicationTrType, List<MethodInfo> sensibleDocMethods, bool classDocRecommended)
        {
            if (member.IsDefined<UndocumentedAttribute>())
                return;

            if (!(member is Type) && inType.IsSubclassOf(member.DeclaringType))
                inType = member.DeclaringType;

            var attr = member.GetCustomAttributes<DocumentationAttribute>().FirstOrDefault();
            ConsoleColoredString toCheck = null;
            if (attr != null)
            {
                try
                {
                    toCheck = attr.Text; // this property can throw the first time it's accessed
                }
                catch (Exception e)
                {
                    if (member is Type)
                        rep.Error(@"{0}: Type documentation could not be parsed as {1}: {2}".Fmt(((Type) member).FullName, attr.OriginalFormat, e.Message), "class " + member.Name);
                    else
                        rep.Error(@"{0}.{1}: Field documentation could not be parsed as {2}: {3}".Fmt(member.DeclaringType.FullName, member.Name, attr.OriginalFormat, e.Message), "class " + member.DeclaringType.Name, member.Name);
                    return;
                }
            }
            else if (applicationTrType != null)
            {
                var meth = inType.GetMethod(member.Name + "Doc", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { applicationTrType }, null);
                if (meth != null && meth.ReturnType == typeof(string))
                {
                    sensibleDocMethods.Add(meth);
                    if (!_applicationTrCache.ContainsKey(applicationTrType))
                        _applicationTrCache[applicationTrType] = Activator.CreateInstance(applicationTrType);
                    var appTr = _applicationTrCache[applicationTrType];
                    toCheck = (string) meth.Invoke(null, new object[] { appTr });
                    if (toCheck == null)
                    {
                        rep.Error(@"{0}." + member.Name + @"Doc() returned null.".Fmt(inType.FullName), "class " + inType.Name, member.Name + "Doc");
                        return;
                    }
                }
            }

            if (classDocRecommended && toCheck == null)
            {
                if (member is Type)
                {
                    rep.Warning((@"{0} does not have any documentation. " +
                        (applicationTrType == null ? "U" : @"To provide localised documentation, declare a method ""static string {1}Doc({2})"" on {3}. Otherwise, u") +
                        @"se the [DocumentationLiteral] attribute to specify unlocalisable documentation. " +
                        @"Use [Undocumented] to completely hide an option or command from the help screen.").Fmt(((Type) member).FullName, member.Name, applicationTrType != null ? applicationTrType.FullName : null, inType.FullName),
                        ((Type) member).Namespace,
                        "CommandName",
                        "class " + member.Name);
                }
                else
                {
                    rep.Warning((@"{0}.{1} does not have any documentation. " +
                        (applicationTrType == null ? "U" : @"To provide localised documentation, declare a method ""static string {1}Doc({2})"" on {3}. Otherwise, u") +
                        @"se the [DocumentationLiteral] attribute to specify unlocalisable documentation. " +
                        @"Use [Undocumented] to completely hide an option or command from the help screen.").Fmt(member.DeclaringType.FullName, member.Name, applicationTrType != null ? applicationTrType.FullName : null, inType.FullName),
                        member.DeclaringType.Namespace,
                        (member.DeclaringType.IsEnum ? "enum " : member.DeclaringType.IsValueType ? "struct " : "class ") + member.DeclaringType.Name,
                        member.Name);
                }
                return;
            }
        }

        #endregion

        /// <summary>
        ///     Converts the specified <see cref="RhoML"/> parse tree into a console colored string according to
        ///     CommandLineParser-specific rules. This method is used to convert <see cref="DocumentationRhoMLAttribute"/>
        ///     documentation into colored text. See Remarks.</summary>
        /// <remarks>
        ///     A number of named tags have a special meaning. Any tag named after a value of <see cref="ConsoleColor"/>
        ///     results in that color. Both spellings of gray/grey are supported. The {h}...{} named tag stands for the
        ///     highlight color (white). {nowrap}...{} can be placed around text that must not be broken into multiple lines
        ///     by the word wrapper. The tags {field}, {option}, {command} and {enum} are used to refer to the corresponding
        ///     command line syntax element, and is highlighted the same way the documentation generator would highlight
        ///     references to these entities.</remarks>
        public static ConsoleColoredString Colorize(RhoElement text)
        {
            var strings = new List<ConsoleColoredString>();
            if (text.Name == null)
                colorizeChildren(text, strings, ConsoleColor.Gray, false);
            else
                colorizeWalk(text, strings, ConsoleColor.Gray, false);
            return new ConsoleColoredString(strings);
        }

        /// <summary>
        ///     Converts the specified <see cref="EggsML"/> parse tree into a console colored string using the rules described
        ///     in <see cref="EggsNode.ToConsoleColoredStringWordWrap"/>. This method is used to convert <see
        ///     cref="DocumentationEggsMLAttribute"/> documentation into colored text, as well as any documentation using the
        ///     legacy <see cref="DocumentationLiteralAttribute"/>.</summary>
        public static ConsoleColoredString Colorize(EggsNode text)
        {
            return text.ToConsoleColoredStringWordWrap(int.MaxValue).JoinColoredString(Environment.NewLine);
        }

        private static void colorizeChildren(RhoElement text, List<ConsoleColoredString> strings, ConsoleColor curColor, bool curNowrap)
        {
            foreach (var child in text.Children)
            {
                if (child is RhoText)
                    strings.Add(nowrap((child as RhoText).Text, curNowrap).Color(curColor));
                else
                    colorizeWalk(child as RhoElement, strings, curColor, curNowrap);
            }
        }

        private static void colorizeWalk(RhoElement text, List<ConsoleColoredString> strings, ConsoleColor curColor, bool curNowrap)
        {
            var name = text.Name.ToLower();
            if (name == "field")
            {
                validateNoAttributes(text);
                validateOnlyTextChild(text);
                strings.Add("<".Color(CmdLineColor.FieldBrackets) + nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
            }
            else if (name == "option")
            {
                validateNoAttributes(text);
                validateOnlyTextChild(text);
                strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Option));
            }
            else if (name == "command")
            {
                validateNoAttributes(text);
                validateOnlyTextChild(text);
                strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Command));
            }
            else if (name == "enum")
            {
                validateNoAttributes(text);
                validateOnlyTextChild(text);
                strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.EnumValue));
            }
            else if (name == "nowrap")
            {
                validateNoAttributes(text);
                colorizeChildren(text, strings, curColor, true);
            }
            else if (name == "n") // newline
            {
                validateNoAttributes(text);
                validateNoChildren(text);
                strings.Add("\n");
            }
            else if (name == "h") // highlight
            {
                validateNoAttributes(text);
                colorizeChildren(text, strings, CmdLineColor.Highlight, curNowrap);
            }
            else
            {
                if (!EnumStrong.TryParse<ConsoleColor>(name, out curColor, true))
                {
                    if (name == "grey")
                        curColor = ConsoleColor.Gray;
                    else if (name == "darkgrey")
                        curColor = ConsoleColor.DarkGray;
                    else
                        throw new ArgumentException("Unsupported element: {0}.".Fmt(text.Name), "text");
                }
                validateNoAttributes(text);
                colorizeChildren(text, strings, curColor, curNowrap);
            }
        }

        private static string nowrap(string text, bool doNowrap = true)
        {
            if (doNowrap)
                return text.Replace(' ', '\xA0'); // non-breaking space
            else
                return text;
        }

        private static void validateNoAttributes(RhoElement text)
        {
            if (text.Value != null || text.Attributes.Any())
                throw new ArgumentException("Element {0} must not have any attributes.".Fmt(text.Name), "text");
        }

        private static void validateNoChildren(RhoElement text)
        {
            if (text.Children.Any())
                throw new ArgumentException("Element {0} must not have any child nodes.".Fmt(text.Name), "text");
        }

        private static void validateOnlyTextChild(RhoElement text)
        {
            if (text.Children.Count != 1 || !(text.Children[0] is RhoText))
                throw new ArgumentException("Element {0} must only contain text, and no other elements.".Fmt(text.Name), "text");
        }
    }

    internal static class CmdLineColor
    {
        public const ConsoleColor Option = ConsoleColor.Yellow;
        public const ConsoleColor FieldBrackets = ConsoleColor.DarkCyan;
        public const ConsoleColor Field = ConsoleColor.Cyan;
        public const ConsoleColor Command = ConsoleColor.Green;
        public const ConsoleColor EnumValue = ConsoleColor.Green;
        public const ConsoleColor UsageLinePrefix = ConsoleColor.Green;
        public const ConsoleColor OptionalityDelimiters = ConsoleColor.DarkGray; // e.g. [foo|bar] has [, ] and | in this color
        public const ConsoleColor SubcommandsPresentAsterisk = ConsoleColor.DarkYellow;
        public const ConsoleColor UnexpectedArgument = ConsoleColor.Magenta;
        public const ConsoleColor Error = ConsoleColor.Red;
        public const ConsoleColor HelpHeading = ConsoleColor.White;
        public const ConsoleColor Highlight = ConsoleColor.White;
    }

    /// <summary>
    ///     Contains methods to validate a set of parameters passed by the user on the command-line and parsed by <see
    ///     cref="CommandLineParser"/>. Use this class only in monolingual (unlocalisable) applications. Use <see
    ///     cref="ICommandLineValidatable{TTranslation}"/> otherwise.</summary>
    public interface ICommandLineValidatable
    {
        /// <summary>
        ///     When overridden in a derived class, returns an error message if the contents of the class are invalid,
        ///     otherwise returns null.</summary>
        ConsoleColoredString Validate();
    }

    /// <summary>
    ///     Contains methods to validate a set of parameters passed by the user on the command-line and parsed by <see
    ///     cref="CommandLineParser"/>.</summary>
    /// <typeparam name="TTranslation">
    ///     A translation-string class containing the error messages that can occur during validation.</typeparam>
    public interface ICommandLineValidatable<in TTranslation> where TTranslation : TranslationBase
    {
        /// <summary>
        ///     When implemented in a class, returns an error message if the contents of the class are invalid, otherwise
        ///     returns null.</summary>
        /// <param name="tr">
        ///     Contains translations for the messages that may occur during validation.</param>
        ConsoleColoredString Validate(TTranslation tr);
    }

    /// <summary>Groups the translatable strings in the <see cref="Translation"/> class into categories.</summary>
    public enum TranslationGroup
    {
        /// <summary>Error messages produced by the command-line parser.</summary>
        [LingoGroup("Command-line errors", "Contains messages informing the user of invalid command-line syntax.")]
        CommandLineError,
        /// <summary>Messages used by the command-line parser to produce help pages.</summary>
        [LingoGroup("Command-line help", "Contains messages used to construct help pages for command-line options and parameters.")]
        CommandLineHelp
    }

    /// <summary>Contains translatable strings pertaining to the command-line parser, including error messages and usage help.</summary>
    public sealed class Translation : TranslationBase
    {
#pragma warning disable 1591    // Missing XML comment for publicly visible type or member
        public Translation() : base(Language.EnglishUS) { }

        [LingoInGroup(TranslationGroup.CommandLineError)]
        public TrString
            IncompatibleCommandOrOption = @"The command or option, {0}, cannot be used in conjunction with {1}. Please specify only one of the two.",
            IncompleteOption = @"The {0} option must be followed by an additional parameter.",
            InvalidNumber = @"The {0} option expects a number. The specified parameter does not constitute a valid number.",
            MissingOption = @"The option {0} is mandatory and must be specified.",
            MissingOptionBefore = @"The option {0} is mandatory and must be specified before the {1} parameter.",
            MissingParameter = @"The parameter {0} is mandatory and must be specified.",
            MissingParameterBefore = @"The parameter {0} is mandatory and must be specified before the {1} parameter.",
            UnexpectedParameter = @"Unexpected parameter: {0}",
            UnrecognizedCommandOrOption = @"The specified command or option, {0}, is not recognized.",
            UserRequestedHelp = @"The user has requested help using one of the help options.";

        [LingoInGroup(TranslationGroup.CommandLineHelp)]
        public TrString
            AdditionalOptions = @"This command accepts further arguments on the command line. Type the command followed by *-?* or *help* to list them.",
            Error = @"Error:",
            OptionsHeader = @"Optional parameters:",
            ParametersHeader = @"Required parameters:",
            Usage = @"Usage:";

#pragma warning restore 1591    // Missing XML comment for publicly visible type or member
    }

    /// <summary>Use this on an abstract class to specify that its subclasses represent various commands.</summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class CommandGroupAttribute : Attribute
    {
        /// <summary>Constructor.</summary>
        public CommandGroupAttribute() { }
    }

    /// <summary>
    ///     Use this on a sub-class of an abstract class or on an enum value to specify the command the user must use to
    ///     invoke that class or enum value.</summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
    public sealed class CommandNameAttribute : Attribute
    {
        /// <summary>
        ///     Constructor.</summary>
        /// <param name="names">
        ///     The command(s) the user can specify to invoke this class or enum value.</param>
        public CommandNameAttribute(params string[] names) { Names = names; }
        /// <summary>The command the user can specify to invoke this class.</summary>
        public string[] Names { get; private set; }
    }

    /// <summary>Use this to specify that a command-line parameter is mandatory.</summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
    public sealed class IsMandatoryAttribute : Attribute
    {
        /// <summary>Constructor.</summary>
        public IsMandatoryAttribute() { }
    }

    /// <summary>
    ///     Use this to specify that a command-line parameter is positional, i.e. is not invoked by an option that starts with
    ///     "-".</summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
    public sealed class IsPositionalAttribute : Attribute
    {
        /// <summary>Constructor.</summary>
        public IsPositionalAttribute() { }
    }

    /// <summary>
    ///     Use this to specify that a field in a class can be specified on the command line using an option, for example
    ///     <c>-a</c> or <c>--option-name</c>. The option name(s) MUST begin with a dash (<c>-</c>).</summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
    public sealed class OptionAttribute : Attribute
    {
        /// <summary>
        ///     Constructor.</summary>
        /// <param name="names">
        ///     The name of the option. Specify several names as synonyms if required.</param>
        public OptionAttribute(params string[] names) { Names = names; }
        /// <summary>All of the names of the option.</summary>
        public string[] Names { get; private set; }
    }

    /// <summary>
    ///     Use this attribute to link a command-line option or command with the help text that describes (documents) it.
    ///     Suitable for single-language applications only. See Remarks.</summary>
    /// <remarks>
    ///     This attribute specifies the documentation in plain text. All characters are printed exactly as specified. You may
    ///     wish to use <see cref="DocumentationRhoMLAttribute"/> to specify documentation with special markup for
    ///     command-line-related concepts, as well as <see cref="DocumentationEggsMLAttribute"/> for an alternative markup
    ///     language without command-line specific concepts.</remarks>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
    public class DocumentationAttribute : Attribute
    {
        /// <summary>
        ///     Gets the console-colored documentation string. Note that this property may throw if the text couldn't be
        ///     parsed where applicable.</summary>
        public virtual ConsoleColoredString Text { get { return OriginalText; } }
        /// <summary>Gets a string describing the documentation format to the programmer (not seen by the users).</summary>
        public virtual string OriginalFormat { get { return "Plain text"; } }
        /// <summary>Gets the original documentation string exactly as specified in the attribute.</summary>
        public string OriginalText { get; private set; }

        /// <summary>Constructor.</summary>
        public DocumentationAttribute(string documentation)
        {
            OriginalText = documentation;
        }
    }

    /// <summary>
    ///     Use this attribute to link a command-line option or command with the help text that describes (documents) it.
    ///     Suitable for single-language applications only. The documentation is to be specified in <see cref="RhoML"/>, which
    ///     is interpreted as described in <see cref="CommandLineParser.Colorize(RhoElement)"/>. See also <see
    ///     cref="DocumentationAttribute"/>.</summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
    public class DocumentationRhoMLAttribute : DocumentationAttribute
    {
        /// <summary>Gets a string describing the documentation format to the programmer (not seen by the users).</summary>
        public override string OriginalFormat { get { return "RhoML"; } }
        /// <summary>
        ///     Gets the console-colored documentation string. Note that this property may throw if the text couldn't be
        ///     parsed where applicable.</summary>
        public override ConsoleColoredString Text
        {
            get { return _parsed ?? (_parsed = CommandLineParser.Colorize(RhoML.Parse(OriginalText))); }
        }
        private ConsoleColoredString _parsed;
        /// <summary>Constructor.</summary>
        public DocumentationRhoMLAttribute(string documentation) : base(documentation) { }
    }

    /// <summary>
    ///     Use this attribute to link a command-line option or command with the help text that describes (documents) it.
    ///     Suitable for single-language applications only. The documentation is to be specified in <see cref="EggsML"/>,
    ///     which is interpreted as described in <see cref="CommandLineParser.Colorize(EggsNode)"/>. See also <see
    ///     cref="DocumentationRhoMLAttribute"/> and <see cref="DocumentationAttribute"/>.</summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
    public class DocumentationEggsMLAttribute : DocumentationAttribute
    {
        /// <summary>Gets a string describing the documentation format to the programmer (not seen by the users).</summary>
        public override string OriginalFormat { get { return "EggsML"; } }
        /// <summary>
        ///     Gets the console-colored documentation string. Note that this property may throw if the text couldn't be
        ///     parsed where applicable.</summary>
        public override ConsoleColoredString Text
        {
            get { return _parsed ?? (_parsed = CommandLineParser.Colorize(EggsML.Parse(OriginalText))); }
        }
        private ConsoleColoredString _parsed;
        /// <summary>Constructor.</summary>
        public DocumentationEggsMLAttribute(string documentation) : base(documentation) { }
    }

    /// <summary>
    ///     This is a legacy attribute. Do not use in new programs. This attribute is equivalent to <see
    ///     cref="DocumentationEggsMLAttribute"/>.</summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
    public class DocumentationLiteralAttribute : DocumentationEggsMLAttribute
    {
        /// <summary>Constructor.</summary>
        public DocumentationLiteralAttribute(string documentation) : base(documentation) { }
    }

    /// <summary>
    ///     Specifies that a specific command-line option should not be printed in help pages, i.e. the option should
    ///     explicitly be undocumented.</summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
    public sealed class UndocumentedAttribute : Attribute
    {
        /// <summary>Constructor.</summary>
        public UndocumentedAttribute() { }
    }

    /// <summary>Describes the behavior of an enum-typed field with the <see cref="EnumOptionsAttribute"/>.</summary>
    public enum EnumBehavior
    {
        /// <summary>Specifies that an enum is considered to represent a single value.</summary>
        SingleValue,
        /// <summary>Specifies that an enum is considered to represent a bitfield containing multiple values.</summary>
        MultipleValues
    }

    /// <summary>
    ///     Specifies that a field of an enum type should be interpreted as multiple possible options, each specified by an
    ///     <see cref="OptionAttribute"/> on the enum values in the enum type.</summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    public sealed class EnumOptionsAttribute : Attribute
    {
        /// <summary>Constructor.</summary>
        public EnumOptionsAttribute(EnumBehavior behavior) { Behavior = behavior; }

        /// <summary>
        ///     Specifies whether the enum is considered to represent a single value or a bitfield containing multiple values.</summary>
        public EnumBehavior Behavior { get; private set; }
    }

    /// <summary>Specifies that the command-line parser should ignore a field.</summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    public sealed class IgnoreAttribute : Attribute
    {
        /// <summary>Constructor.</summary>
        public IgnoreAttribute() { }
    }

    /// <summary>Represents any error encountered while parsing a command line. This class is abstract.</summary>
    [Serializable]
    public abstract class CommandLineParseException : TranslatableException<Translation>
    {
        /// <summary>
        ///     Generates the help screen to be output to the user on the console. For non-internationalised (single-language)
        ///     applications, pass null for the Translation parameter.</summary>
        internal Func<Translation, int, ConsoleColoredString> GenerateHelpFunc { get; private set; }
        /// <summary>Contains the error message that describes the cause of this exception.</summary>
        public Func<Translation, ConsoleColoredString> GetColoredMessage { get; private set; }
        /// <summary>
        ///     Generates the help screen to be output to the user on the console.</summary>
        /// <param name="tr">
        ///     The translation class containing the translated text, or <c>null</c> for English.</param>
        /// <param name="wrapWidth">
        ///     The character width at which the output should be word-wrapped. The default (<c>null</c>) uses <see
        ///     cref="ConsoleUtil.WrapToWidth"/>.</param>
        public ConsoleColoredString GenerateHelp(Translation tr, int? wrapWidth = null) { return GenerateHelpFunc(tr, wrapWidth ?? ConsoleUtil.WrapToWidth()); }
        /// <summary>
        ///     Generates a printable description of the error represented by this exception, typically used to tell the user
        ///     what they did wrong.</summary>
        /// <param name="tr">
        ///     The translation class containing the translated text, or <c>null</c> for English.</param>
        /// <param name="wrapWidth">
        ///     The character width at which the output should be word-wrapped. The default (<c>null</c>) uses <see
        ///     cref="ConsoleUtil.WrapToWidth"/>.</param>
        public ConsoleColoredString GenerateErrorText(Translation tr, int? wrapWidth = null)
        {
            if (tr == null)
                tr = new Translation();

            var strings = new List<ConsoleColoredString>();
            var message = tr.Error.Translation.Color(CmdLineColor.Error) + " " + GetColoredMessage(tr);
            foreach (var line in message.WordWrap(wrapWidth ?? ConsoleUtil.WrapToWidth(), tr.Error.Translation.Length + 1))
            {
                strings.Add(line);
                strings.Add(Environment.NewLine);
            }
            return new ConsoleColoredString(strings);
        }

        /// <summary>Constructor.</summary>
        public CommandLineParseException(Func<Translation, ConsoleColoredString> getMessage, Func<Translation, int, ConsoleColoredString> helpGenerator) : this(getMessage, helpGenerator, null) { }
        /// <summary>Constructor.</summary>
        public CommandLineParseException(Func<Translation, ConsoleColoredString> getMessage, Func<Translation, int, ConsoleColoredString> helpGenerator, Exception inner)
            : base(tr => getMessage(tr).ToString(), inner)
        {
            GenerateHelpFunc = helpGenerator;
            GetColoredMessage = getMessage;
        }

        /// <summary>
        ///     Prints usage information, followed by an error message describing to the user what it was that the parser
        ///     didn't understand.</summary>
        /// <param name="tr">
        ///     Contains translations for the messages used by the command-line parser. Set this to null only if your
        ///     application is definitely monolingual (unlocalisable).</param>
        public virtual void WriteUsageInfoToConsole(Translation tr = null)
        {
            if (tr == null)
                tr = new Translation();

            ConsoleUtil.Write(GenerateHelp(tr, ConsoleUtil.WrapToWidth()));

            Console.WriteLine();
            ConsoleUtil.Write(GenerateErrorText(tr, ConsoleUtil.WrapToWidth()));
        }
    }

    /// <summary>Indicates that the user supplied one of the standard options we recognize as a help request.</summary>
    [Serializable]
    public sealed class CommandLineHelpRequestedException : CommandLineParseException
    {
        /// <summary>Constructor.</summary>
        public CommandLineHelpRequestedException(Func<Translation, int, ConsoleColoredString> helpGenerator)
            : base(tr => tr.UserRequestedHelp.Color(ConsoleColor.Gray), helpGenerator)
        {
        }

        /// <summary>
        ///     Prints usage information.</summary>
        /// <param name="tr">
        ///     Contains translations for the messages used by the command-line parser. Set this to null only if your
        ///     application is definitely monolingual (unlocalisable).</param>
        public override void WriteUsageInfoToConsole(Translation tr = null)
        {
            if (tr == null)
                tr = new Translation();

            ConsoleUtil.Write(GenerateHelp(tr, ConsoleUtil.WrapToWidth()));
        }
    }

    /// <summary>
    ///     Specifies that the arguments specified by the user on the command-line do not pass the custom validation checks.</summary>
    [Serializable]
    public sealed class CommandLineValidationException : CommandLineParseException
    {
        /// <summary>Constructor.</summary>
        public CommandLineValidationException(ConsoleColoredString message, Func<Translation, int, ConsoleColoredString> helpGenerator) : base(tr => message, helpGenerator) { }
    }

    /// <summary>
    ///     Specifies that the command-line parser encountered a command or option that was not recognised (there was no <see
    ///     cref="OptionAttribute"/> or <see cref="CommandNameAttribute"/> attribute with a matching option or command name).</summary>
    [Serializable]
    public sealed class UnrecognizedCommandOrOptionException : CommandLineParseException
    {
        /// <summary>The unrecognized command name or option name.</summary>
        public string CommandOrOptionName { get; private set; }
        /// <summary>Constructor.</summary>
        public UnrecognizedCommandOrOptionException(string commandOrOptionName, Func<Translation, int, ConsoleColoredString> helpGenerator) : this(commandOrOptionName, helpGenerator, null) { }
        /// <summary>Constructor.</summary>
        public UnrecognizedCommandOrOptionException(string commandOrOptionName, Func<Translation, int, ConsoleColoredString> helpGenerator, Exception inner)
            : base(tr => tr.UnrecognizedCommandOrOption.ToConsoleColoredString().Fmt(commandOrOptionName.Color(ConsoleColor.White)), helpGenerator, inner)
        {
            CommandOrOptionName = commandOrOptionName;
        }
    }

    /// <summary>
    ///     Specifies that the command-line parser encountered a command or option that is not allowed in conjunction with a
    ///     previously-encountered command or option.</summary>
    [Serializable]
    public sealed class IncompatibleCommandOrOptionException : CommandLineParseException
    {
        /// <summary>
        ///     The earlier option or command, which by itself is valid, but conflicts with the <see
        ///     cref="LaterCommandOrOption"/>.</summary>
        public string EarlierCommandOrOption { get; private set; }
        /// <summary>The later option or command, which conflicts with the <see cref="EarlierCommandOrOption"/>.</summary>
        public string LaterCommandOrOption { get; private set; }
        /// <summary>Constructor.</summary>
        public IncompatibleCommandOrOptionException(string earlier, string later, Func<Translation, int, ConsoleColoredString> helpGenerator) : this(earlier, later, helpGenerator, null) { }
        /// <summary>Constructor.</summary>
        public IncompatibleCommandOrOptionException(string earlier, string later, Func<Translation, int, ConsoleColoredString> helpGenerator, Exception inner)
            : base(tr => tr.IncompatibleCommandOrOption.ToConsoleColoredString().Fmt(later.Color(ConsoleColor.White), earlier.Color(ConsoleColor.White)), helpGenerator, inner)
        {
            EarlierCommandOrOption = earlier;
            LaterCommandOrOption = later;
        }
    }

    /// <summary>
    ///     Specifies that the command-line parser encountered the end of the command line when it expected an argument to an
    ///     option.</summary>
    [Serializable]
    public sealed class IncompleteOptionException : CommandLineParseException
    {
        /// <summary>The name of the option that was missing an argument.</summary>
        public string OptionName { get; private set; }
        /// <summary>Constructor.</summary>
        public IncompleteOptionException(string optionName, Func<Translation, int, ConsoleColoredString> helpGenerator) : this(optionName, helpGenerator, null) { }
        /// <summary>Constructor.</summary>
        public IncompleteOptionException(string optionName, Func<Translation, int, ConsoleColoredString> helpGenerator, Exception inner)
            : base(tr => tr.IncompleteOption.ToConsoleColoredString().Fmt(optionName.Color(ConsoleColor.White)), helpGenerator, inner)
        {
            OptionName = optionName;
        }
    }

    /// <summary>
    ///     Specifies that the command-line parser encountered additional command-line arguments when it expected the end of
    ///     the command line.</summary>
    [Serializable]
    public sealed class UnexpectedArgumentException : CommandLineParseException
    {
        /// <summary>Contains the first unexpected argument and all of the subsequent arguments.</summary>
        public string[] UnexpectedParameters { get; private set; }
        /// <summary>Constructor.</summary>
        public UnexpectedArgumentException(string[] unexpectedArgs, Func<Translation, int, ConsoleColoredString> helpGenerator) : this(unexpectedArgs, helpGenerator, null) { }
        /// <summary>Constructor.</summary>
        public UnexpectedArgumentException(string[] unexpectedArgs, Func<Translation, int, ConsoleColoredString> helpGenerator, Exception inner)
            : base(tr => tr.UnexpectedParameter.ToConsoleColoredString().Fmt(unexpectedArgs.Select(prm => prm.Length > 50 ? prm.Substring(0, 47) + "..." : prm).FirstOrDefault().Color(CmdLineColor.UnexpectedArgument)), helpGenerator, inner)
        {
            UnexpectedParameters = unexpectedArgs;
        }
    }

    /// <summary>
    ///     Specifies that a parameter that expected a numerical value was passed a string by the user that doesn’t parse as a
    ///     number.</summary>
    [Serializable]
    public sealed class InvalidNumericParameterException : CommandLineParseException
    {
        /// <summary>Contains the name of the field pertaining to the parameter that was passed an invalid value.</summary>
        public string FieldName { get; private set; }
        /// <summary>Constructor.</summary>
        public InvalidNumericParameterException(string fieldName, Func<Translation, int, ConsoleColoredString> helpGenerator) : this(fieldName, helpGenerator, null) { }
        /// <summary>Constructor.</summary>
        public InvalidNumericParameterException(string fieldName, Func<Translation, int, ConsoleColoredString> helpGenerator, Exception inner)
            : base(tr => tr.InvalidNumber.ToConsoleColoredString().Fmt("<".Color(CmdLineColor.FieldBrackets) + fieldName.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets)), helpGenerator, inner)
        {
            FieldName = fieldName;
        }
    }

    /// <summary>
    ///     Specifies that the command-line parser encountered the end of the command line when it expected additional
    ///     mandatory options.</summary>
    [Serializable]
    public sealed class MissingParameterException : CommandLineParseException
    {
        /// <summary>Contains the field pertaining to the parameter that was missing.</summary>
        public FieldInfo Field { get; private set; }
        /// <summary>Contains an optional reference to a field which the missing parameter must precede.</summary>
        public FieldInfo BeforeField { get; private set; }
        /// <summary>
        ///     Specifies whether the missing parameter was a missing option (true) or a missing positional parameter (false).</summary>
        public bool IsOption { get; private set; }
        /// <summary>Constructor.</summary>
        public MissingParameterException(FieldInfo paramField, FieldInfo beforeField, bool isOption, Func<Translation, int, ConsoleColoredString> helpGenerator) : this(paramField, beforeField, isOption, helpGenerator, null) { }
        /// <summary>Constructor.</summary>
        public MissingParameterException(FieldInfo paramField, FieldInfo beforeField, bool isOption, Func<Translation, int, ConsoleColoredString> helpGenerator, Exception inner)
            : base(tr => getMessage(tr, paramField, beforeField, isOption), helpGenerator, inner) { Field = paramField; BeforeField = beforeField; IsOption = isOption; }

        private static ConsoleColoredString getMessage(Translation tr, FieldInfo field, FieldInfo beforeField, bool isOption)
        {
            if (beforeField == null)
                return (isOption ? tr.MissingOption : tr.MissingParameter).ToConsoleColoredString().Fmt(field.FormatParameterUsage(true));

            return (isOption ? tr.MissingOptionBefore : tr.MissingParameterBefore).ToConsoleColoredString().Fmt(
                field.FormatParameterUsage(true),
                "<".Color(CmdLineColor.FieldBrackets) + beforeField.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }
    }

    static class CmdLineExtensions
    {
        public static string[] GetOrderedOptionAttributeNames(this MemberInfo member)
        {
            var attr = member.GetCustomAttributes<OptionAttribute>().FirstOrDefault();
            return attr == null ? null : attr.Names.OrderBy(compareOptionNames).ToArray();
        }

        private static int compareOptionNames(string opt1, string opt2)
        {
            bool long1 = opt1.StartsWith("--");
            bool long2 = opt2.StartsWith("--");
            if (long1 == long2)
                return StringComparer.OrdinalIgnoreCase.Compare(opt1, opt2);
            else if (long1)
                return 1; // --blah comes after -blah
            else
                return -1;
        }

        public static ConsoleColoredString FormatParameterUsage(this FieldInfo field, bool isMandatory)
        {
            // Positionals
            if (field.IsDefined<IsPositionalAttribute>())
                return (isMandatory ? "{0}" : "[{0}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                    "<".Color(CmdLineColor.FieldBrackets) + field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));

            // -t name [-t name [...]]    — arrays, multi-value enums with CommandNames
            if (field.FieldType.IsArray ||
                (field.FieldType.IsEnum &&
                    field.IsDefined<OptionAttribute>() &&
                    field.IsDefined<EnumOptionsAttribute>() &&
                    field.GetCustomAttributes<EnumOptionsAttribute>().First().Behavior == EnumBehavior.MultipleValues))
            {
                return (isMandatory ? "{0} {1} [{0} {1} [...]]" : "[{0} {1} [{0} {1} [...]]]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                    field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option),
                    "<".Color(CmdLineColor.FieldBrackets) + field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
            }

            // Enums with Option names
            if (field.FieldType.IsEnum && !field.IsDefined<OptionAttribute>())
            {
                var options = field.FieldType.GetFields(BindingFlags.Public | BindingFlags.Static)
                    .Where(fld => fld.IsDefined<OptionAttribute>() && !fld.IsDefined<UndocumentedAttribute>())
                    .Select(fi => fi.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option))
                    .ToArray();

                if (field.IsDefined<EnumOptionsAttribute>() && field.GetCustomAttributes<EnumOptionsAttribute>().First().Behavior == EnumBehavior.MultipleValues)
                    // [-t] [-u] [-v]    — multi-value enums with Option names
                    return options.Select(opt => "[{0}]".Color(CmdLineColor.OptionalityDelimiters).Fmt(opt)).JoinColoredString(" ");

                // {-t|-u}      — single-value enums with Options
                return (isMandatory ? (options.Length > 1 ? "{{{0}{1}" : "{0}") : "[{0}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(options.JoinColoredString("|".Color(CmdLineColor.OptionalityDelimiters)), "}");
            }

            // -t       — bools
            if (field.FieldType == typeof(bool))
                return "[{0}]".Color(CmdLineColor.OptionalityDelimiters).Fmt(field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option));

            // -t name
            return (isMandatory ? "{0} {1}" : "[{0} {1}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option),
                "<".Color(CmdLineColor.FieldBrackets) + field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }
    }
}

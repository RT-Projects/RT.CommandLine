using System.Diagnostics;
using System.Reflection;
using RT.Internal;
using RT.PostBuild;
using RT.Util;
using RT.Util.Consoles;
using RT.Util.ExtensionMethods;
using RT.Util.Text;

namespace RT.CommandLine;

/// <summary>
///     Implements a command-line parser that can turn the commands and options specified by the user on the command line into
///     a strongly-typed instance of a specific class. See remarks for more details.</summary>
/// <remarks>
///     <para>
///         The following conditions must be met by the class wishing to receive the options and parameters:</para>
///     <list type="bullet">
///         <item><description>
///             It must be a reference type (a class) and it must have a parameterless constructor.</description></item>
///         <item><description>
///             <para>
///                 Every field in the class must have one of the following custom attributes:</para>
///             <list type="bullet">
///                 <item><description>
///                     <see cref="IsPositionalAttribute"/> (allowed for all supported types except <c>bool</c>) — specifies
///                     that the field is a positional parameter; the user specifies this as a single parameter without any
///                     extra syntax.</description></item>
///                 <item><description>
///                     <see cref="OptionAttribute"/> (allowed for all supported types except abstract classes) — specifies
///                     that the field is a parameter invoked by an option, e.g. <c>-x</c>. (This does not imply that the
///                     parameter is necessarily optional.)</description></item>
///                 <item><description>
///                     <see cref="EnumOptionsAttribute"/> (allowed for enum types only) — specifies that the field is a
///                     parameter that can be invoked by one of several options, which are specified on the enum values in the
///                     enum type.</description></item>
///                 <item><description>
///                     <see cref="IgnoreAttribute"/> — specifies that <see cref="CommandLineParser"/> shall completely ignore
///                     the field.</description></item></list></description></item>
///         <item><description>
///             <para>
///                 Each field may optionally have any of the following custom attributes:</para>
///             <list type="bullet">
///                 <item><description>
///                     <see cref="IsMandatoryAttribute"/> (allowed for all supported types except <c>bool</c>) — specifies
///                     that the parameter must be specified by the user. For a <c>string[]</c> field, it means that at least
///                     one value must be specified.</description></item>
///                 <item><description>
///                     <see cref="UndocumentedAttribute"/> — specifies that the option or command does not appear in the help
///                     screen generated by CommandLineParser.</description></item></list></description></item>
///         <item><description>
///             <para>
///                 Each field in the class must be of one of the following types:</para>
///             <list type="bullet">
///                 <item><description>
///                     <c>string</c>, any integer type, <c>float</c>, <c>double</c>, or any nullable version of these. The
///                     field can be positional (<see cref="IsPositionalAttribute"/>) or not (<see cref="OptionAttribute"/>).</description></item>
///                 <item><description>
///                     <c>string[]</c>. The field can be positional (<see cref="IsPositionalAttribute"/>) or not (<see
///                     cref="OptionAttribute"/>), but if it is positional, it must be the last field in the class.</description></item>
///                 <item><description>
///                     <c>bool</c>. The field must have an <see cref="OptionAttribute"/> and cannot be positional or
///                     mandatory.</description></item>
///                 <item><description>
///                     An abstract class with the <see cref="CommandGroupAttribute"/>. The field must be the last field in
///                     the class and must be marked positional (<see cref="IsPositionalAttribute"/>). The abstract class must
///                     have at least two derived classes, each with a <see cref="CommandNameAttribute"/>.</description></item>
///                 <item><description>
///                     <para>
///                         Any enum type. There are three ways that enum types can be used. To explain these, the following
///                         enum type declaraction is used as an example:</para>
///                     <code>
///                         enum OutputFormat { PlainText, Xml }</code>
///                     <list type="bullet">
///                         <item><description>
///                             <para>
///                                 <see cref="IsPositionalAttribute"/> — The user can specify a single parameter (e.g.
///                                 <c>plain</c> or <c>xml</c>) to select an enum value. Every value in the enum type must
///                                 have a <see cref="CommandNameAttribute"/> to specify the name by which that enum value is
///                                 selected:</para>
///                             <code>
///                                 enum OutputFormat
///                                 {
///                                     [CommandName("plain")]
///                                     PlainText,
///                                     [CommandName("xml")]
///                                     Xml
///                                 }</code></description></item>
///                         <item><description>
///                             <see cref="OptionAttribute"/> — The user can select an enum value by specifying an option
///                             followed by a parameter that identifies the enum value (e.g. <c>-x plain</c> or <c>-x
///                             xml</c>). As above, every value in the enum type must have a <see
///                             cref="CommandNameAttribute"/> to specify the name by which that enum value is selected.</description></item>
///                         <item><description>
///                             <para>
///                                 <see cref="EnumOptionsAttribute"/> — The user can select an enum value by specifying just
///                                 an option (e.g. <c>-p</c> or <c>-x</c>). Every value in the enum type must have an <see
///                                 cref="OptionAttribute"/> to specify the option by which that enum value is selected:</para>
///                             <code>
///                                 enum OutputFormat
///                                 {
///                                     [Option("-p", "--plain")]
///                                     PlainText,
///                                     [Option("-x", "--xml")]
///                                     Xml
///                                 }</code>
///                             <para>
///                                 A parameter on the attribute determines whether the user is allowed to specify only one
///                                 enum value or multiple (which will be combined using bitwise or).</para></description></item>
///                         <item><description>
///                             If the field is optional, the enum value that corresponds to the field’s initial (default)
///                             value may omit the <see cref="CommandNameAttribute"/> or <see cref="OptionAttribute"/>.</description></item></list></description></item></list></description></item>
///         <item><description>
///             <para>
///                 Every field must have documentation or be explicitly marked with <see cref="UndocumentedAttribute"/>,
///                 except for fields that use <see cref="EnumOptionsAttribute"/> or <see cref="IgnoreAttribute"/>. For every
///                 field whose type is an enum type, the values in the enum type must also have documentation or <see
///                 cref="UndocumentedAttribute"/>, except for the enum value that corresponds to the field’s default value if
///                 the field is not mandatory.</para>
///             <para>
///                 Documentation is provided in one of the following ways:</para>
///             <list type="bullet">
///                 <item><description>
///                     Monolingual, translation-agnostic (unlocalisable) applications use the <see
///                     cref="DocumentationAttribute"/> to specify documentation directly.</description></item>
///                 <item><description>
///                     <para>
///                         Translatable applications must declare methods with the following signature:</para>
///                     <code>
///                         static string FieldNameDoc(Translation)</code>
///                     <para>
///                         The first parameter must be of the same type as the object passed in for the <c>applicationTr</c>
///                         parameter of <see cref="Parse"/>. The name of the method is the name of the field or enum value
///                         followed by <c>Doc</c>. The return value is the translated string.</para></description></item></list></description></item>
///         <item><description>
///             <see cref="IsPositionalAttribute"/> and <see cref="IsMandatoryAttribute"/> can be used together. However, a
///             positional field can only be made mandatory if all the positional fields preceding it are also mandatory.</description></item></list></remarks>
public static class CommandLineParser
{
    /// <summary>
    ///     Parses the specified command-line arguments into an instance of the specified type. See the remarks section of the
    ///     documentation for <see cref="CommandLineParser"/> for features and limitations.</summary>
    /// <typeparam name="TArgs">
    ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
    /// <param name="args">
    ///     The command-line arguments to be parsed.</param>
    /// <param name="helpProcessor">
    ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
    ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
    /// <returns>
    ///     An instance of the class <typeparamref name="TArgs"/> containing the options and parameters specified by the user
    ///     on the command line.</returns>
    public static TArgs Parse<TArgs>(string[] args, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
    {
        return (TArgs) parseCommandLine(args, typeof(TArgs), 0, helpProcessor);
    }

    /// <summary>
    ///     Parses the specified command-line arguments into an instance of the specified type. In case of failure, prints
    ///     usage information to the console and returns <c>default(TArgs)</c>. See the remarks section of the documentation
    ///     for <see cref="CommandLineParser"/> for features and limitations.</summary>
    /// <typeparam name="TArgs">
    ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
    /// <param name="args">
    ///     The command-line arguments to be parsed.</param>
    /// <param name="helpProcessor">
    ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
    ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
    /// <returns>
    ///     An instance of the class <typeparamref name="TArgs"/> containing the options and parameters specified by the user
    ///     on the command line.</returns>
    public static TArgs ParseOrWriteUsageToConsole<TArgs>(string[] args, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
    {
        try
        {
            return (TArgs) parseCommandLine(args, typeof(TArgs), 0, helpProcessor);
        }
        catch (CommandLineParseException e)
        {
            e.WriteUsageInfoToConsole();
            return default;
        }
    }

    private sealed class PositionalParameterInfo
    {
        public Action ProcessParameter;
        public Action ProcessEndOfParameters;
    }

    /// <summary>
    ///     Generates the help screen for this command line.</summary>
    /// <typeparam name="TArgs">
    ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
    /// <param name="wrapWidth">
    ///     The character width at which the output should be word-wrapped. The default (<c>null</c>) uses <see
    ///     cref="ConsoleUtil.WrapToWidth"/>.</param>
    /// <param name="subType">
    ///     Optionally, a class that is used as a subcommand within the command-line syntax. Generates help for the
    ///     subcommand.</param>
    /// <param name="helpProcessor">
    ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
    ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
    public static ConsoleColoredString GenerateHelp<TArgs>(int? wrapWidth = null, Type subType = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
    {
        return getHelpGenerator(subType ?? typeof(TArgs), helpProcessor)(wrapWidth ?? ConsoleUtil.WrapToWidth());
    }

    private static object parseCommandLine(string[] args, Type type, int i, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        if (i < args.Length)
            if (args[i] == "-?" || args[i] == "/?" || args[i] == "--?" || args[i] == "/h" || args[i] == "--help" || args[i] == "-help" || args[i] == "help")
                throw new CommandLineHelpRequestedException(getHelpGenerator(type, helpProcessor));

        var ret = Activator.CreateInstance(type, true);
        var options = new Dictionary<string, Action>();
        var positionals = new List<PositionalParameterInfo>();
        var missingMandatories = new List<FieldInfo>();
        FieldInfo swallowingField = null;
        var haveSeenOptionalPositional = false;

        foreach (var field in type.GetCommandLineFields())
        {
            var positional = field.IsDefined<IsPositionalAttribute>();
            var option = field.GetCustomAttributes<OptionAttribute>().FirstOrDefault();
            var mandatory = field.IsDefined<IsMandatoryAttribute>();

            if (positional && mandatory && haveSeenOptionalPositional)
                throw new InternalErrorException("Cannot have positional mandatory parameter after a positional optional one.");

            if (positional && !mandatory)
                haveSeenOptionalPositional = true;

            if (mandatory)
                missingMandatories.Add(field);

            // ### ENUM fields
            if (field.FieldType.IsEnum)
            {
                // ### ENUM fields, positional
                if (positional)
                {
                    positionals.Add(new PositionalParameterInfo
                    {
                        ProcessParameter = () =>
                        {
                            positionals.RemoveAt(0);
                            missingMandatories.Remove(field);
                            foreach (var enumField in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
                            {
                                if (enumField.GetCustomAttributes<CommandNameAttribute>().First().Names.Any(c => c.Equals(args[i], StringComparison.OrdinalIgnoreCase)))
                                {
                                    field.SetValue(ret, enumField.GetValue(null));
                                    i++;
                                    return;
                                }
                            }
                            throw new UnrecognizedCommandOrOptionException(args[i], getHelpGenerator(type, helpProcessor));
                        },
                        ProcessEndOfParameters = () =>
                        {
                            if (mandatory)
                                throw new MissingParameterException(field, null, false, getHelpGenerator(type, helpProcessor));
                        }
                    });
                }
                // ### ENUM fields
                else
                {
                    // Take care of both option+name scheme (e.g. “-x foo -x bar”) and option scheme (e.g. “-x -y”)
                    var behavior = field.GetCustomAttributes<EnumOptionsAttribute>().Select(eoa => eoa.Behavior).FirstOrDefault(EnumBehavior.SingleValue);
                    var underlyingType = field.FieldType.GetEnumUnderlyingType();

                    var infos = option == null
                        ? field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).Select(enumField => new
                        {
                            Options = enumField.GetOrderedOptionAttributeNames(),
                            NeedCommandName = false,
                            GetEnumValue = Ut.Lambda((string commandName) => enumField.GetRawConstantValue())
                        })
                        : Ut.NewArray(new
                        {
                            Options = option.Names,
                            NeedCommandName = true,
                            GetEnumValue = Ut.Lambda((string commandName) =>
                            {
                                var enumField = field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public)
                                    .FirstOrDefault(ef => ef.GetCustomAttributes<CommandNameAttribute>().Any(cna => cna.Names.Contains(commandName)))
                                    ?? throw new UnrecognizedCommandOrOptionException(commandName, getHelpGenerator(type, helpProcessor));
                                return enumField.GetRawConstantValue();
                            })
                        });

                    object prev = null;
                    string prevOptionOrCommand = null;

                    foreach (var inf in infos)
                    {
                        if (inf.Options == null)
                            // Assume that this is the default option
                            continue;
                        foreach (var o in inf.Options)
                        {
                            options[o] = () =>
                            {
                                i++;
                                string commandName = null;
                                if (inf.NeedCommandName)
                                {
                                    if (i >= args.Length)
                                        throw new IncompleteOptionException(o, getHelpGenerator(type, helpProcessor));
                                    commandName = args[i];
                                    i++;
                                }
                                missingMandatories.Remove(field);
                                var value = inf.GetEnumValue(commandName);

                                if (behavior == EnumBehavior.SingleValue)
                                {
                                    if (prev == null)
                                    {
                                        prev = value;
                                        prevOptionOrCommand = commandName ?? o;
                                        field.SetValue(ret, value);
                                    }
                                    else if (prev.Equals(value))
                                    {
                                        // Don’t throw an error if the same value is simply specified multiple times. Just ignore the second occurrence
                                    }
                                    else
                                    {
                                        // Since only a single value is allowed, throw an error if another value is specified later
                                        throw new IncompatibleCommandOrOptionException(prevOptionOrCommand, commandName ?? o, getHelpGenerator(type, helpProcessor));
                                    }
                                }
                                else
                                {
                                    if (underlyingType == typeof(ulong))
                                        prev = (prev == null ? 0UL : (ulong) prev) | (ulong) value;
                                    else
                                        prev = (prev == null ? 0L : Convert.ToInt64(prev)) | Convert.ToInt64(value);
                                    field.SetValue(ret, Convert.ChangeType(prev, underlyingType));
                                }
                            };
                        }
                    }
                }
            }
            // ### BOOL fields
            else if (field.FieldType == typeof(bool))
            {
                foreach (var o in field.GetOrderedOptionAttributeNames() ?? [])
                    options[o] = () => { field.SetValue(ret, true); i++; missingMandatories.Remove(field); };
            }
            // ### STRING and INTEGER fields (including nullable)
            else if (field.FieldType == typeof(string) || ExactConvert.IsTrueIntegerType(field.FieldType) || ExactConvert.IsTrueIntegerNullableType(field.FieldType) ||
                field.FieldType == typeof(float) || field.FieldType == typeof(float?) || field.FieldType == typeof(double) || field.FieldType == typeof(double?))
            {
                if (positional)
                {
                    positionals.Add(new PositionalParameterInfo
                    {
                        ProcessParameter = () =>
                        {
                            if (!convertStringAndSetField(args[i], ret, field))
                                throw new InvalidNumericParameterException(field.Name, getHelpGenerator(type, helpProcessor));

                            positionals.RemoveAt(0);
                            missingMandatories.Remove(field);
                            i++;
                        },
                        ProcessEndOfParameters = () =>
                        {
                            if (mandatory)
                                throw new MissingParameterException(field, null, false, getHelpGenerator(type, helpProcessor));
                        }
                    });
                }
                else
                {
                    foreach (var o in field.GetOrderedOptionAttributeNames() ?? [])
                    {
                        options[o] = () =>
                        {
                            i++;
                            if (i >= args.Length)
                                throw new IncompleteOptionException(o, getHelpGenerator(type, helpProcessor));

                            if (!convertStringAndSetField(args[i], ret, field))
                                throw new InvalidNumericParameterException(field.Name, getHelpGenerator(type, helpProcessor));

                            i++;
                            missingMandatories.Remove(field);
                        };
                    }
                }
            }
            // ### STRING[] fields
            else if (field.FieldType == typeof(string[]))
            {
                if (positional)
                {
                    positionals.Add(new PositionalParameterInfo
                    {
                        ProcessParameter = () =>
                        {
                            missingMandatories.Remove(field);
                            var prev = (string[]) field.GetValue(ret);
                            if (prev == null || prev.Length == 0)
                                field.SetValue(ret, new string[] { args[i] });
                            else
                                field.SetValue(ret, prev.Concat(args[i]).ToArray());
                            i++;
                        },
                        ProcessEndOfParameters = () =>
                        {
                            if (field.GetValue(ret) == null)
                                field.SetValue(ret, Array.Empty<string>());
                        }
                    });
                }
                else
                {
                    string[] prev = null;
                    foreach (var o in field.GetOrderedOptionAttributeNames() ?? [])
                    {
                        options[o] = () =>
                        {
                            i++;
                            if (i >= args.Length)
                                throw new IncompleteOptionException(o, getHelpGenerator(type, helpProcessor));
                            prev = (prev == null || prev.Length == 0)
                                ? [args[i]]
                                : prev.Concat(args[i]).ToArray();
                            field.SetValue(ret, prev);
                            i++;
                            missingMandatories.Remove(field);
                        };
                    }
                }
            }
            // ### Command-group classes
            else if (field.FieldType.IsClass && field.FieldType.IsDefined<CommandGroupAttribute>())
            {
                swallowingField = field;
                positionals.Add(new PositionalParameterInfo
                {
                    ProcessParameter = () =>
                    {
                        missingMandatories.Remove(field);
                        positionals.RemoveAt(0);
                        foreach (var subclass in allTypes().Where(t => !t.IsAbstract && t.IsSubclassOf(field.FieldType)))
                            if (subclass.GetCustomAttributes<CommandNameAttribute>().First().Names.Any(c => c.Equals(args[i], StringComparison.OrdinalIgnoreCase)))
                            {
                                field.SetValue(ret, parseCommandLine(args, subclass, i + 1, helpProcessor));
                                i = args.Length;
                                return;
                            }
                        throw new UnrecognizedCommandOrOptionException(args[i], getHelpGenerator(type, helpProcessor));
                    },
                    ProcessEndOfParameters = () =>
                    {
                        if (mandatory)
                            throw new MissingParameterException(field, null, false, getHelpGenerator(type, helpProcessor));
                    }
                });
            }
            else
                // This only happens if the post-build check didn't run
                throw new InternalErrorException($"{type.FullName}.{field.Name} is not of a supported type.");
        }

        bool suppressOptions = false;

        while (i < args.Length)
        {
            if (args[i] == "--" && !suppressOptions)
            {
                suppressOptions = true;
                i++;
            }
            else if (!suppressOptions && args[i].StartsWith('-'))
            {
                if (options.TryGetValue(args[i], out var opt))
                    opt();
                else
                    throw new UnrecognizedCommandOrOptionException(args[i], getHelpGenerator(type, helpProcessor));
            }
            else
            {
                if (positionals.Count == 0)
                    throw new UnexpectedArgumentException(args.Subarray(i), getHelpGenerator(type, helpProcessor));
                positionals[0].ProcessParameter();
            }
        }

        if (positionals.Count > 0)
            positionals[0].ProcessEndOfParameters();

        if (missingMandatories.Count > 0)
            throw new MissingParameterException(missingMandatories[0], swallowingField, !missingMandatories[0].IsDefined<IsPositionalAttribute>(), getHelpGenerator(type, helpProcessor));

        ConsoleColoredString error = null;
        if (typeof(ICommandLineValidatable).IsAssignableFrom(type))
            error = ((ICommandLineValidatable) ret).Validate();

        if (error != null)
            throw new CommandLineValidationException(error, getHelpGenerator(type, helpProcessor));

        return ret;
    }

    private static IEnumerable<Type> allTypes() => AppDomain.CurrentDomain.GetAssemblies().SelectMany(asm => asm.GetTypes());

    private static bool convertStringAndSetField(string value, object cmdLineObject, FieldInfo field)
    {
        object result;

        if (field.FieldType == typeof(string))
            result = value;
        else
        {
            Type type = field.FieldType.IsGenericType && field.FieldType.GetGenericTypeDefinition() == typeof(Nullable<>)
                ? field.FieldType.GetGenericArguments()[0]
                : field.FieldType;
            if (!ExactConvert.Try(type, value, out result))
                return false;
        }
        field.SetValue(cmdLineObject, result);
        return true;
    }

    private static Func<int, ConsoleColoredString> getHelpGenerator(Type type, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        helpProcessor ??= (s => s);
        return wrapWidth =>
        {
            int leftMargin = 3;

            var helpString = new List<ConsoleColoredString>();
            var commandNameAttr = type.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
            string commandName = commandNameAttr == null ? Process.GetCurrentProcess().ProcessName : "... " + commandNameAttr.Names.OrderByDescending(c => c.Length).First();

            //
            //  ##  CONSTRUCT THE “USAGE” LINE
            //
            var usage = new List<ConsoleColoredString>
            {
                new("Usage: ", CmdLineColor.UsageLinePrefix),
                commandName
            };

            getFieldsForHelp(type, out var optionalOptions, out var mandatoryOptions, out var optionalPositional, out var mandatoryPositional);

            // Options must be listed before positionals because if a positional is a subcommand, all the options must be before it.
            // optionalPositional must come after mandatoryPositional because that is the order they must be specified in.
            // If any mandatoryPositional is a subcommand, then you can’t have any optionalPositionals anyway.
            usage.Add(
                mandatoryOptions.Select(fld => new { Mandatory = true, Field = fld })
                    .Concat(optionalOptions.Select(fld => new { Mandatory = false, Field = fld }))
                    .Concat(mandatoryPositional.Select(fld => new { Mandatory = true, Field = fld }))
                    .Concat(optionalPositional.Select(fld => new { Mandatory = false, Field = fld }))
                    .Select(f => " " + f.Field.FormatParameterUsage(f.Mandatory))
                    .JoinColoredString());

            // Word-wrap the usage line
            foreach (var line in new ConsoleColoredString(usage.ToArray()).WordWrap(wrapWidth, "Usage: ".Length))
            {
                helpString.Add(line);
                helpString.Add(ConsoleColoredString.NewLine);
            }
            helpString.Add(ConsoleColoredString.NewLine);

            //
            //  ##  CONSTRUCT THE TABLES
            //

            var anyCommandsWithSuboptions = false;
            var requiredParamsTable = new TextTable { MaxWidth = wrapWidth - leftMargin, ColumnSpacing = 3, RowSpacing = 1, LeftMargin = leftMargin };
            int requiredRow = 0;
            foreach (var f in mandatoryPositional.Select(fld => new { Positional = true, Field = fld }).Concat(mandatoryOptions.Select(fld => new { Positional = false, Field = fld })))
                anyCommandsWithSuboptions |= createParameterHelpRow(ref requiredRow, requiredParamsTable, f.Field, f.Positional, helpProcessor);

            var optionalParamsTable = new TextTable { MaxWidth = wrapWidth - leftMargin, ColumnSpacing = 3, RowSpacing = 1, LeftMargin = leftMargin };
            int optionalRow = 0;
            foreach (var f in optionalPositional.Select(fld => new { Positional = true, Field = fld }).Concat(optionalOptions.Select(fld => new { Positional = false, Field = fld })))
                anyCommandsWithSuboptions |= createParameterHelpRow(ref optionalRow, optionalParamsTable, f.Field, f.Positional, helpProcessor);

            // Word-wrap the documentation for the command (if any)
            var doc = getDocumentation(type, helpProcessor);
            foreach (var line in doc.WordWrap(wrapWidth))
            {
                helpString.Add(line);
                helpString.Add(ConsoleColoredString.NewLine);
            }

            // Table of required parameters
            if (mandatoryOptions.Count > 0 || mandatoryPositional.Count > 0)
            {
                helpString.Add(ConsoleColoredString.NewLine);
                helpString.Add(new ConsoleColoredString("Required parameters:", CmdLineColor.HelpHeading));
                helpString.Add(ConsoleColoredString.NewLine);
                helpString.Add(ConsoleColoredString.NewLine);
                requiredParamsTable.RemoveEmptyColumns();
                helpString.Add(requiredParamsTable.ToColoredString());
            }

            // Table of optional parameters
            if (optionalOptions.Count > 0 || optionalPositional.Count > 0)
            {
                helpString.Add(ConsoleColoredString.NewLine);
                helpString.Add(new ConsoleColoredString("Optional parameters:", CmdLineColor.HelpHeading));
                helpString.Add(ConsoleColoredString.NewLine);
                helpString.Add(ConsoleColoredString.NewLine);
                optionalParamsTable.RemoveEmptyColumns();
                helpString.Add(optionalParamsTable.ToColoredString());
            }

            // “This command accepts further arguments on the command line.”
            if (anyCommandsWithSuboptions)
            {
                helpString.Add(ConsoleColoredString.NewLine);
                foreach (var line in (new ConsoleColoredString("* ", CmdLineColor.SubcommandsPresentAsterisk) + ConsoleColoredString.FromEggsNode(EggsML.Parse("This command accepts further arguments on the command line. Type the command followed by *-?* or *help* to list them."))).WordWrap(wrapWidth, 2))
                {
                    helpString.Add(line);
                    helpString.Add(ConsoleColoredString.NewLine);
                }
            }

            return new ConsoleColoredString(helpString.ToArray());
        };
    }

    private static bool createParameterHelpRow(ref int row, TextTable table, FieldInfo field, bool positional, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        var anyCommandsWithSuboptions = false;
        var cmdName = "<".Color(CmdLineColor.FieldBrackets) + field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets);

        if (field.FieldType.IsEnum)
        {
            // ### ENUM fields, positional
            if (positional)
            {
                var topRow = row;
                var doc = getDocumentation(field, helpProcessor);
                if (doc.Length > 0 || field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).All(el => el.IsDefined<UndocumentedAttribute>() || !el.GetCustomAttributes<CommandNameAttribute>().Any()))
                {
                    table.SetCell(2, row, doc, colSpan: 4);
                    row++;
                }
                foreach (var el in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
                {
                    if (el.IsDefined<UndocumentedAttribute>())
                        continue;
                    var attr = el.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
                    if (attr == null)   // skip the default value
                        continue;
                    table.SetCell(2, row, attr.Names.Where(n => n.Length <= 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(", "), noWrap: true);
                    table.SetCell(3, row, attr.Names.Where(n => n.Length > 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(Environment.NewLine), noWrap: true);
                    table.SetCell(4, row, getDocumentation(el, helpProcessor), colSpan: 2);
                    row++;
                }
                table.SetCell(0, topRow, cmdName, noWrap: true, colSpan: 2, rowSpan: row - topRow);
            }
            // ### ENUM fields, “-x foo” scheme
            else if (field.IsDefined<OptionAttribute>())
            {
                var topRow = row;
                row++;
                foreach (var el in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).Where(e => !e.IsDefined<UndocumentedAttribute>()))
                {
                    var attr = el.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
                    if (attr == null)   // skip the default value
                        continue;
                    table.SetCell(3, row, attr.Names.Where(n => n.Length <= 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(", "), noWrap: true);
                    table.SetCell(4, row, attr.Names.Where(n => n.Length > 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(Environment.NewLine), noWrap: true);
                    table.SetCell(5, row, getDocumentation(el, helpProcessor));
                    row++;
                }
                if (row == topRow + 1)
                    throw new InvalidOperationException($"Enum type {field.FieldType.DeclaringType.FullName}.{field.FieldType} has no values (apart from default value for field {field.DeclaringType.FullName}.{field.Name}).");
                table.SetCell(0, topRow, field.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true, rowSpan: row - topRow);
                table.SetCell(1, topRow, field.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true, rowSpan: row - topRow);
                table.SetCell(2, topRow, getDocumentation(field, helpProcessor), colSpan: 4);
                table.SetCell(2, topRow + 1, cmdName, noWrap: true, rowSpan: row - topRow - 1);
            }
            // ### ENUM fields, “-x” scheme
            else
            {
                foreach (var el in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).Where(e => e.IsDefined<OptionAttribute>() && !e.IsDefined<UndocumentedAttribute>()))
                {
                    table.SetCell(0, row, el.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true);
                    table.SetCell(1, row, el.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true);
                    table.SetCell(2, row, getDocumentation(el, helpProcessor), colSpan: 4);
                    row++;
                }
            }
        }
        // ### Command-group classes
        else if (field.FieldType.IsDefined<CommandGroupAttribute>())
        {
            int origRow = row;
            foreach (var ty in allTypes()
                .Where(t => t.IsSubclassOf(field.FieldType) && t.IsDefined<CommandNameAttribute>() && !t.IsAbstract && !t.IsDefined<UndocumentedAttribute>())
                .OrderBy(t => t.GetCustomAttributes<CommandNameAttribute>().First().Names.MinElement(c => c.Length)))
            {
                var cell1 = ConsoleColoredString.Empty;
                var cell2 = ConsoleColoredString.Empty;
                var suboptions = ty.GetAllFields().Any(fld => !fld.IsDefined<UndocumentedAttribute>());
                anyCommandsWithSuboptions |= suboptions;
                var asterisk = suboptions ? "*".Color(CmdLineColor.SubcommandsPresentAsterisk) : ConsoleColoredString.Empty;
                var names = ty.GetCustomAttributes<CommandNameAttribute>().First().Names;
                table.SetCell(2, row, names.Where(n => n.Length <= 2).Select(n => n.Color(CmdLineColor.Command) + asterisk).JoinColoredString(", "), noWrap: true);
                table.SetCell(3, row, names.Where(n => n.Length > 2).Select(n => n.Color(CmdLineColor.Command) + asterisk).JoinColoredString(Environment.NewLine), noWrap: true);
                table.SetCell(4, row, getDocumentation(ty, helpProcessor), colSpan: 2);
                row++;
            }
            table.SetCell(0, origRow, cmdName, colSpan: 2, rowSpan: row - origRow, noWrap: true);
        }
        // ### All other positional parameters
        else if (positional)
        {
            table.SetCell(0, row, cmdName, noWrap: true, colSpan: 2);
            table.SetCell(2, row, getDocumentation(field, helpProcessor), colSpan: 4);
            row++;
        }
        // ### All other non-positional parameters
        else
        {
            table.SetCell(0, row, field.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true);
            table.SetCell(1, row, field.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true);
            table.SetCell(2, row, getDocumentation(field, helpProcessor), colSpan: 4);
            row++;
        }
        return anyCommandsWithSuboptions;
    }

    private static void getFieldsForHelp(Type type, out List<FieldInfo> optionalOptions, out List<FieldInfo> mandatoryOptions, out List<FieldInfo> optionalPositional, out List<FieldInfo> mandatoryPositional)
    {
        optionalOptions = [];
        mandatoryOptions = [];
        optionalPositional = [];
        mandatoryPositional = [];

        foreach (var field in type.GetCommandLineFields().Where(f => !f.IsDefined<UndocumentedAttribute>()))
        {
            var fieldInfos = field.IsDefined<IsMandatoryAttribute>()
                ? (field.IsDefined<IsPositionalAttribute>() ? mandatoryPositional : mandatoryOptions)
                : (field.IsDefined<IsPositionalAttribute>() ? optionalPositional : optionalOptions);
            fieldInfos.Add(field);
        }
    }

    private static ConsoleColoredString getDocumentation(MemberInfo member, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor) =>
        member.IsDefined<DocumentationAttribute>() ? helpProcessor(member.GetCustomAttributes<DocumentationAttribute>().Select(d => d.Text ?? "").First()) : "";

    #region Post-build step check

    /// <summary>
    ///     Performs safety checks to ensure that the structure of your command-line syntax defining class is valid according
    ///     to the criteria laid out in the documentation of <see cref="CommandLineParser"/>. Run this method as a post-build
    ///     step to ensure reliability of execution. For an example of use, see <see
    ///     cref="PostBuildChecker.RunPostBuildChecks(string, Assembly[])"/>.</summary>
    /// <typeparam name="TArgs">
    ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
    /// <param name="rep">
    ///     Object to report post-build errors to.</param>
    public static void PostBuildStep<TArgs>(IPostBuildReporter rep)
    {
        postBuildStep(rep, typeof(TArgs), false);
    }

    private static void postBuildStep(IPostBuildReporter rep, Type commandLineType, bool classDocRecommended)
    {
        if (!commandLineType.IsClass)
            rep.Error($"{commandLineType.FullName} is not a class.", (commandLineType.IsEnum ? "enum " : commandLineType.IsInterface ? "interface " : typeof(Delegate).IsAssignableFrom(commandLineType) ? "delegate " : "struct ") + commandLineType.Name);

        object instance;
        try
        {
            instance = Activator.CreateInstance(commandLineType, true);
        }
        catch (Exception e)
        {
            rep.Error($"{commandLineType.FullName} could not be instantiated ({e.Message}). Does it have a default constructor?", "class " + commandLineType.Name);
            return;
        }

        var optionTaken = new Dictionary<string, MemberInfo>();
        var sensibleDocMethods = new List<MethodInfo>();
        FieldInfo lastField = null;
        bool haveSeenOptionalPositional = false;

        checkDocumentation(rep, commandLineType, classDocRecommended);

        foreach (var field in commandLineType.GetCommandLineFields())
        {
            if (lastField != null)
                rep.Error($"The type of {lastField.DeclaringType.FullName}.{lastField.Name} necessitates that it is the last one in the class.", "class " + commandLineType.Name, field.Name);

            // Every field must have one of the following
            var positional = field.IsDefined<IsPositionalAttribute>();
            var options = field.GetOrderedOptionAttributeNames();
            var enumOpt = field.GetCustomAttributes<EnumOptionsAttribute>().FirstOrDefault();

            if (!positional && options == null && enumOpt == null)
            {
                rep.Error($"{field.DeclaringType.FullName}.{field.Name}: Every field must have one of the following attributes: [IsPositional], [Option], [EnumOptions] (fields of an enum type only), or [Ignore].", "class " + commandLineType.Name, field.Name);
                continue;
            }

            // EnumOptionsAttribute can only be used on enum fields
            if (enumOpt != null && !field.FieldType.IsEnum)
                rep.Error($"{field.DeclaringType.FullName}.{field.Name}: Cannot use [EnumOptions] attribute on a field whose type is not an enum type.", "class " + commandLineType.Name, field.Name);
            // Can’t combine IsPositional and Option
            else if (positional && options != null)
                rep.Error($"{field.DeclaringType.FullName}.{field.Name}: Cannot use [IsPositional] and [Option] attributes on the same field.", "class " + commandLineType.Name, field.Name);
            // Can’t combine IsPositional and EnumOptions
            else if (positional && enumOpt != null)
                rep.Error($"{field.DeclaringType.FullName}.{field.Name}: Cannot use [IsPositional] and [EnumOptions] attributes on the same field. For a positional enum value, use only [IsPositional].", "class " + commandLineType.Name, field.Name);
            // Can’t have [Option] without an option name
            else if (options != null && options.Length == 0)
                rep.Error($"{field.DeclaringType.FullName}.{field.Name}: An [Option] attribute must specify at least one option name.", "class " + commandLineType.Name, field.Name);

            // Option names must start with a dash
            if (options != null && options.Any(o => !o.StartsWith('-')))
                rep.Error($@"{field.DeclaringType.FullName}.{field.Name}: All names in an [Option] attribute must start with at least one dash ('-'). Offending option name: “{options.First(o => !o.StartsWith('-'))}”", "class " + commandLineType.Name, field.Name);

            var mandatory = field.IsDefined<IsMandatoryAttribute>();

            if (mandatory && field.IsDefined<UndocumentedAttribute>())
                rep.Error($"{field.DeclaringType.FullName}.{field.Name}: Fields cannot simultaneously be mandatory and also undocumented.", "class " + commandLineType.Name, field.Name);

            if (positional && mandatory && haveSeenOptionalPositional)
                rep.Error($"{field.DeclaringType.FullName}.{field.Name}: Positional fields can only be marked mandatory if all preceding positional fields are also marked mandatory.", "class " + commandLineType.Name, field.Name);
            else if (positional && !mandatory)
                haveSeenOptionalPositional = true;

            // ### ENUM fields
            if (field.FieldType.IsEnum)
            {
                // Can’t have a mandatory or a positional multi-value enum
                if (mandatory && enumOpt != null && enumOpt.Behavior == EnumBehavior.MultipleValues)
                    rep.Error($"{field.DeclaringType.FullName}.{field.Name}: A mandatory enum field cannot use multi-value behavior.", "class " + commandLineType.Name, field.Name);
                if (positional && enumOpt != null && enumOpt.Behavior == EnumBehavior.MultipleValues)
                    rep.Error($"{field.DeclaringType.FullName}.{field.Name}: A positional enum field cannot use multi-value behavior.", "class " + commandLineType.Name, field.Name);

                var commandsTaken = new Dictionary<string, FieldInfo>();
                var defaultValue = field.GetValue(instance);

                foreach (var enumField in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
                {
                    if (enumField.IsDefined<IgnoreAttribute>())
                        continue;
                    // If the field is not mandatory, it is allowed to have a default value
                    if (!mandatory && enumField.GetValue(null).Equals(defaultValue))
                        continue;

                    // check that the enum values all have documentation
                    checkDocumentation(rep, enumField, true);

                    if (options != null || positional)
                    {
                        // check that the enum values all have at least one CommandName, and they do not clash
                        var cmdNames = enumField.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
                        if (cmdNames == null || cmdNames.Names.Length == 0)
                            rep.Error($"{field.FieldType.FullName}.{enumField.Name} (used by {commandLineType.FullName}.{field.Name}): Enum value must have a [CommandName] attribute (unless it is the field's default value and the field is optional).", "enum " + field.FieldType.Name, enumField.Name);
                        else
                            checkCommandNamesUnique(rep, cmdNames.Names, commandsTaken, commandLineType, field, enumField);
                    }
                    else
                    {
                        // check that the non-default enum values’ Options are present and do not clash
                        var optionNames = enumField.GetOrderedOptionAttributeNames();
                        if (optionNames == null || optionNames.Length > 0)
                            rep.Error($"{field.FieldType.FullName}.{enumField.Name} (used by {commandLineType.FullName}.{field.Name}): Enum value must have an [Option] attribute with at least one option name (unless it is the field's default value and the field is optional).", "enum " + field.FieldType.Name, enumField.Name);
                        else
                            checkOptionsUnique(rep, optionNames, optionTaken, commandLineType, field, enumField);
                    }
                }

                // If the enum field has an Option attribute, it needs documentation too
                if (options != null)
                    checkDocumentation(rep, field, true);
            }
            // ### BOOL fields
            else if (field.FieldType == typeof(bool))
            {
                if (positional || mandatory)
                    rep.Error($"{commandLineType.FullName}.{field.Name}: Fields of type bool cannot be positional or mandatory.", "class " + commandLineType.Name, field.Name);
                else
                    // Here we have checked that the field is not positional, not an enum, and not [Ignore]’d, so it must have an [Option] attribute
                    checkOptionsUnique(rep, options, optionTaken, commandLineType, field);
                checkDocumentation(rep, field, true);
            }
            // ### STRING, STRING[], INTEGER and FLOATING fields (including nullable)
            else if (field.FieldType == typeof(string) || field.FieldType == typeof(string[]) ||
                (ExactConvert.IsTrueIntegerType(field.FieldType) && !field.FieldType.IsEnum) ||
                (ExactConvert.IsTrueIntegerNullableType(field.FieldType) && !field.FieldType.GetGenericArguments()[0].IsEnum) ||
                field.FieldType == typeof(float) || field.FieldType == typeof(float?) || field.FieldType == typeof(double) || field.FieldType == typeof(double?))
            {
                // options is null if and only if this field is positional
                if (options != null)
                    checkOptionsUnique(rep, options, optionTaken, commandLineType, field);
                checkDocumentation(rep, field, true);
            }
            // ### Command-group classes
            else if (field.FieldType.IsClass && field.FieldType.IsDefined<CommandGroupAttribute>())
            {
                // Command-group class fields must be positional parameters
                if (!positional)
                    rep.Error($"{commandLineType.FullName}.{field.Name}: CommandGroup fields must be declared [IsPositional].", "class " + commandLineType.Name, field.Name);

                // The class must have at least two subclasses with a [CommandName] attribute
                var subclasses = allTypes().Where(t => !t.IsAbstract && t.IsSubclassOf(field.FieldType));
                if (!subclasses.Any())
                    rep.Error($"{commandLineType.FullName}.{field.Name}: The CommandGroup class type must have at least one non-abstract derived class with the [CommandName] attribute.", "class " + field.FieldType.Name);

                var commandsTaken = new Dictionary<string, Type>();

                foreach (var subclass in subclasses)
                {
                    if (!subclass.IsDefined<CommandNameAttribute>())
                        rep.Error($"{subclass.FullName}: This subclass of {field.FieldType.FullName} must have a [CommandName] attribute or be marked abstract.", "class " + subclass.Name);
                    else
                        checkCommandNamesUnique(rep, subclass.GetCustomAttributes<CommandNameAttribute>().First().Names, commandsTaken, subclass);

                    // Recursively check this class
                    postBuildStep(rep, subclass, true);
                }

                lastField = field;
            }
            else
                rep.Error($"{commandLineType.FullName}.{field.Name} is not of a supported type. Currently accepted types are: enum types, bool, string, string[], numeric types (byte, sbyte, short, ushort, int, uint, long, ulong, float and double), nullable numeric types, and classes with the [CommandGroup] attribute.", "class " + commandLineType.Name, field.Name);
        }
    }

    private static void checkOptionsUnique(IPostBuildReporter rep, IEnumerable<string> options, Dictionary<string, MemberInfo> optionTaken, Type type, FieldInfo field, FieldInfo enumField)
    {
        foreach (var option in options)
        {
            if (optionTaken.TryGetValue(option, out var otherField))
            {
                rep.Error($"{field.FieldType.FullName}.{enumField.Name}: Option “{option}” is used more than once.", "enum " + field.FieldType.Name, enumField.Name);
                rep.Error($" -- It is used by {type.FullName}.{field.Name}...", "class " + type.Name, field.Name);
                rep.Error($" -- ... and by {otherField.DeclaringType.FullName}.{otherField.Name}.", "class " + otherField.DeclaringType.Name, otherField.Name);
            }
            optionTaken[option] = field;
        }
    }

    private static void checkOptionsUnique(IPostBuildReporter rep, IEnumerable<string> options, Dictionary<string, MemberInfo> optionTaken, Type type, FieldInfo field)
    {
        foreach (var option in options)
        {
            if (optionTaken.TryGetValue(option, out var otherField))
            {
                rep.Error($"Option “{option}” is used by {type.FullName}.{field.Name}...", "class " + type.Name, field.Name);
                rep.Error($" -- ... and by {otherField.DeclaringType.FullName}.{otherField.Name}.", "class " + otherField.DeclaringType.Name, otherField.Name);
            }
            optionTaken[option] = field;
        }
    }

    private static void checkCommandNamesUnique(IPostBuildReporter rep, string[] commandNames, Dictionary<string, Type> commandsTaken, Type subclass)
    {
        foreach (var cmd in commandNames)
        {
            if (commandsTaken.TryGetValue(cmd, out var otherField))
            {
                rep.Error($"CommandName “{cmd}” is used by {subclass.FullName}...", "class " + subclass.Name);
                rep.Error($" -- ... and by {otherField.FullName}.", "class " + otherField.Name);
            }
            commandsTaken[cmd] = subclass;
        }
    }

    private static void checkCommandNamesUnique(IPostBuildReporter rep, string[] commandNames, Dictionary<string, FieldInfo> commandsTaken, Type type, FieldInfo field, FieldInfo enumField)
    {
        foreach (var cmd in commandNames)
        {
            if (commandsTaken.TryGetValue(cmd, out var otherField))
            {
                rep.Error($"{field.FieldType.FullName}.{enumField.Name}: Option “{cmd}” is used more than once.", "enum " + field.FieldType.Name, enumField.Name);
                rep.Error($" -- It is used by {type.FullName}.{field.Name}...", "class " + type.Name, field.Name);
                rep.Error($" -- ... and by {otherField.DeclaringType.FullName}.{otherField.Name}.", "class " + otherField.DeclaringType.Name, otherField.Name);
            }
            commandsTaken[cmd] = enumField;
        }
    }

    private static void checkDocumentation(IPostBuildReporter rep, MemberInfo member, bool classDocRecommended)
    {
        if (member.IsDefined<UndocumentedAttribute>())
            return;

        var attr = member.GetCustomAttributes<DocumentationAttribute>().FirstOrDefault();
        ConsoleColoredString toCheck = null;
        if (attr != null)
        {
            try
            {
                toCheck = attr.Text; // this property can throw the first time it's accessed
            }
            catch (Exception e)
            {
                if (member is Type type)
                    rep.Error($"{type.FullName}: Type documentation could not be parsed as {attr.OriginalFormat}: {e.Message}", "class " + member.Name);
                else
                    rep.Error($"{member.DeclaringType.FullName}.{member.Name}: Field documentation could not be parsed as {attr.OriginalFormat}: {e.Message}", "class " + member.DeclaringType.Name, member.Name);
                return;
            }
        }

        if (classDocRecommended && toCheck == null)
        {
            if (member is Type type)
            {
                rep.Warning((@"{0} does not have any documentation. " +
                    @"Use the [DocumentationLiteral] attribute to specify unlocalisable documentation. " +
                    @"Use [Undocumented] to completely hide an option or command from the help screen.").Fmt(type.FullName),
                    type.Namespace,
                    "CommandName",
                    "class " + member.Name);
            }
            else
            {
                rep.Warning((@"{0}.{1} does not have any documentation. " +
                    @"Use the [DocumentationLiteral] attribute to specify unlocalisable documentation. " +
                    @"Use [Undocumented] to completely hide an option or command from the help screen.").Fmt(member.DeclaringType.FullName, member.Name),
                    member.DeclaringType.Namespace,
                    (member.DeclaringType.IsEnum ? "enum " : member.DeclaringType.IsValueType ? "struct " : "class ") + member.DeclaringType.Name,
                    member.Name);
            }
            return;
        }
    }

    #endregion

    /// <summary>
    ///     Converts the specified <see cref="RhoML"/> parse tree into a console colored string according to
    ///     CommandLineParser-specific rules. This method is used to convert <see cref="DocumentationRhoMLAttribute"/>
    ///     documentation into colored text. See Remarks.</summary>
    /// <remarks>
    ///     A number of named tags have a special meaning. Any tag named after a value of <see cref="ConsoleColor"/> results
    ///     in that color. Both spellings of gray/grey are supported. The {h}...{} named tag stands for the highlight color
    ///     (white). {nowrap}...{} can be placed around text that must not be broken into multiple lines by the word wrapper.
    ///     The tags {field}, {option}, {command} and {enum} are used to refer to the corresponding command line syntax
    ///     element, and is highlighted the same way the documentation generator would highlight references to these entities.</remarks>
    public static ConsoleColoredString Colorize(RhoElement text)
    {
        var strings = new List<ConsoleColoredString>();
        if (text.Name == null)
            colorizeChildren(text, strings, ConsoleColor.Gray, false);
        else
            colorizeWalk(text, strings, ConsoleColor.Gray, false);
        return new ConsoleColoredString(strings);
    }

    /// <summary>
    ///     Converts the specified <see cref="EggsML"/> parse tree into a console colored string using the rules described in
    ///     <see cref="EggsNode.ToConsoleColoredStringWordWrap"/>. This method is used to convert <see
    ///     cref="DocumentationEggsMLAttribute"/> documentation into colored text, as well as any documentation using the
    ///     legacy <see cref="DocumentationLiteralAttribute"/>.</summary>
    public static ConsoleColoredString Colorize(EggsNode text)
    {
        return text.ToConsoleColoredStringWordWrap(int.MaxValue).JoinColoredString(Environment.NewLine);
    }

    private static void colorizeChildren(RhoElement text, List<ConsoleColoredString> strings, ConsoleColor curColor, bool curNowrap)
    {
        foreach (var child in text.Children)
        {
            if (child is RhoText)
                strings.Add(nowrap((child as RhoText).Text, curNowrap).Color(curColor));
            else
                colorizeWalk(child as RhoElement, strings, curColor, curNowrap);
        }
    }

    private static void colorizeWalk(RhoElement text, List<ConsoleColoredString> strings, ConsoleColor curColor, bool curNowrap)
    {
        var name = text.Name.ToLower();
        if (name == "field")
        {
            validateNoAttributes(text);
            validateOnlyTextChild(text);
            strings.Add("<".Color(CmdLineColor.FieldBrackets) + nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }
        else if (name == "option")
        {
            validateNoAttributes(text);
            validateOnlyTextChild(text);
            strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Option));
        }
        else if (name == "command")
        {
            validateNoAttributes(text);
            validateOnlyTextChild(text);
            strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Command));
        }
        else if (name == "enum")
        {
            validateNoAttributes(text);
            validateOnlyTextChild(text);
            strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.EnumValue));
        }
        else if (name == "nowrap")
        {
            validateNoAttributes(text);
            colorizeChildren(text, strings, curColor, true);
        }
        else if (name == "n") // newline
        {
            validateNoAttributes(text);
            validateNoChildren(text);
            strings.Add("\n");
        }
        else if (name == "h") // highlight
        {
            validateNoAttributes(text);
            colorizeChildren(text, strings, CmdLineColor.Highlight, curNowrap);
        }
        else
        {
            if (!EnumStrong.TryParse<ConsoleColor>(name, out curColor, true))
            {
                if (name == "grey")
                    curColor = ConsoleColor.Gray;
                else if (name == "darkgrey")
                    curColor = ConsoleColor.DarkGray;
                else
                    throw new ArgumentException($"Unsupported element: {text.Name}.", nameof(text));
            }
            validateNoAttributes(text);
            colorizeChildren(text, strings, curColor, curNowrap);
        }
    }

    private static string nowrap(string text, bool doNowrap = true)
    {
        if (doNowrap)
            return text.Replace(' ', '\xA0'); // non-breaking space
        else
            return text;
    }

    private static void validateNoAttributes(RhoElement text)
    {
        if (text.Value != null || text.Attributes.Any())
            throw new ArgumentException($"Element {text.Name} must not have any attributes.", nameof(text));
    }

    private static void validateNoChildren(RhoElement text)
    {
        if (text.Children.Any())
            throw new ArgumentException($"Element {text.Name} must not have any child nodes.", nameof(text));
    }

    private static void validateOnlyTextChild(RhoElement text)
    {
        if (text.Children.Count != 1 || text.Children[0] is not RhoText)
            throw new ArgumentException($"Element {text.Name} must only contain text, and no other elements.", nameof(text));
    }
}
